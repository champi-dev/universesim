import React, { useRef, useEffect, useState } from "react";
import * as THREE from "three";

const UniverseSimulation = () => {
  // Version 2.7 - Debugging material errors
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);
  const cameraRef = useRef(null);
  const frameRef = useRef(0);

  const [timeSpeed, setTimeSpeed] = useState(1);
  const [currentScale, setCurrentScale] = useState("atmosphere");
  const [lodLevel, setLodLevel] = useState(0);
  const [isMobile] = useState(
    /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
  );

  // Camera state with larger range and LOD tracking
  const cameraState = useRef({
    position: new THREE.Vector3(0, 50, 300), // Start at Solar System view (300 AU from Sun)
    lookAt: new THREE.Vector3(0, 0, 0), // Look at Solar System center (Sun)
    velocity: new THREE.Vector3(0, 0, 0),
    lastLodLevel: -1,
    targetVelocity: new THREE.Vector3(0, 0, 0),
    smoothing: 0.92, // Camera smoothing factor
  });

  // LOD thresholds in light-years (scientifically accurate)
  const LOD_THRESHOLDS = {
    ATMOSPHERE: 1e-12,      // ~100m - atmospheric/sky detail
    SURFACE: 1e-8,          // ~100km - planetary surface  
    ORBITAL: 5e-6,          // ~50,000km - orbital mechanics
    STELLAR: 4.3,           // 4.3 light-years - stellar neighborhood
    GALACTIC: 100000,       // 100,000 light-years - galactic scale
    LOCAL_GROUP: 3000000,   // 3 million light-years - local galaxy group
    COSMIC_WEB: 30000000,   // 30 million light-years - cosmic web
    CMB: 13800000000,       // Observable universe edge (13.8 billion ly)
  };

  // LOD system refs
  const lodObjects = useRef({
    atmosphere: null,
    planetary: null,
    stellar: null,
    galactic: null,
    cosmic: null,
    cmb: null,
  });

  // Planetary entry system
  const planetarySystem = useRef({
    isInsidePlanet: false,
    currentPlanet: null,
    surfaceHeight: 0,
    surfaceNormal: new THREE.Vector3(0, 1, 0),
    lockedToSurface: false,
    surfacePosition: new THREE.Vector3(),
    skybox: null,
    entryThreshold: 1.2, // Enter when within 120% of planet radius
    exitThreshold: 2.0,  // Auto-exit when beyond 200% of planet radius
  });

  // Manual exit function - will be set inside useEffect
  const exitPlanetMode = useRef(null);

  useEffect(() => {
    if (!mountRef.current) return;

    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;

    // Scene with massive render distance
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000011, 0.00003);
    sceneRef.current = scene;

    // Camera with extreme range
    const camera = new THREE.PerspectiveCamera(60, width / height, 0.001, 1e15);
    camera.position.copy(cameraState.current.position);
    cameraRef.current = camera;

    // ========== ATMOSPHERIC DETAIL LEVEL ==========
    const createAtmosphericDetail = () => {
      const atmGroup = new THREE.Group();

      // Earth's atmosphere layers (scientifically accurate)
      const atmosphereLayers = [
        { name: 'Troposphere', height: 0.012, color: 0x87CEEB, opacity: 0.3 },
        { name: 'Stratosphere', height: 0.050, color: 0x4169E1, opacity: 0.2 },
        { name: 'Mesosphere', height: 0.085, color: 0x191970, opacity: 0.1 },
        { name: 'Thermosphere', height: 0.600, color: 0x000080, opacity: 0.05 },
      ];

      atmosphereLayers.forEach(layer => {
        const layerGeometry = new THREE.SphereGeometry(6.371 + layer.height, 64, 64);
        const layerMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            sunDirection: { value: new THREE.Vector3(1, 0.5, 0).normalize() },
          },
          vertexShader: `
            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            void main() {
              vNormal = normalize(normalMatrix * normal);
              vec4 worldPosition = modelMatrix * vec4(position, 1.0);
              vWorldPosition = worldPosition.xyz;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform vec3 sunDirection;
            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            
            void main() {
              vec3 color = vec3(${(layer.color >> 16) / 255.0}, ${((layer.color >> 8) & 0xFF) / 255.0}, ${(layer.color & 0xFF) / 255.0});
              
              // Rayleigh scattering approximation
              float cosAngle = dot(vNormal, sunDirection);
              float scattering = 1.0 + cosAngle * cosAngle;
              
              // Atmospheric density falloff
              float altitude = length(vWorldPosition) - 6.371;
              float density = exp(-altitude * 8.0); // Scale height approximation
              
              color *= scattering * density;
              gl_FragColor = vec4(color, ${layer.opacity} * density);
            }
          `,
          transparent: true,
          side: THREE.BackSide,
          blending: THREE.AdditiveBlending,
        });
        
        const layerMesh = new THREE.Mesh(layerGeometry, layerMaterial);
        atmGroup.add(layerMesh);
      });

      // Volumetric clouds with realistic weather patterns
      const cloudGeometry = new THREE.BufferGeometry();
      const cloudCount = 50000;
      const cloudPositions = new Float32Array(cloudCount * 3);
      const cloudSizes = new Float32Array(cloudCount);
      const cloudOpacities = new Float32Array(cloudCount);

      for (let i = 0; i < cloudCount; i++) {
        // Clouds primarily in troposphere (0-12km)
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const altitude = 6.371 + 0.002 + Math.random() * 0.010; // 2-12km altitude
        
        const i3 = i * 3;
        cloudPositions[i3] = altitude * Math.sin(phi) * Math.cos(theta);
        cloudPositions[i3 + 1] = altitude * Math.sin(phi) * Math.sin(theta);
        cloudPositions[i3 + 2] = altitude * Math.cos(phi);
        
        cloudSizes[i] = Math.random() * 0.05 + 0.02; // 20-70km cloud size
        cloudOpacities[i] = Math.random() * 0.8 + 0.2;
      }

      cloudGeometry.setAttribute('position', new THREE.BufferAttribute(cloudPositions, 3));
      cloudGeometry.setAttribute('size', new THREE.BufferAttribute(cloudSizes, 1));
      cloudGeometry.setAttribute('opacity', new THREE.BufferAttribute(cloudOpacities, 1));

      const cloudMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          sunDirection: { value: new THREE.Vector3(1, 0.5, 0).normalize() },
        },
        vertexShader: `
          attribute float size;
          attribute float opacity;
          varying float vOpacity;
          varying vec3 vPosition;
          uniform float time;
          
          void main() {
            vOpacity = opacity;
            vPosition = position;
            
            // Weather pattern movement
            vec3 pos = position;
            pos.x += sin(time * 0.1 + position.y * 0.1) * 0.001;
            pos.z += cos(time * 0.08 + position.x * 0.1) * 0.001;
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (1000.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform vec3 sunDirection;
          varying float vOpacity;
          varying vec3 vPosition;
          
          void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            
            // Cloud density falloff
            float intensity = 1.0 - (r * 2.0);
            intensity = pow(intensity, 2.0);
            
            // Lighting based on sun direction
            vec3 normal = normalize(vPosition);
            float lighting = max(0.3, dot(normal, sunDirection));
            
            vec3 cloudColor = vec3(1.0) * lighting;
            gl_FragColor = vec4(cloudColor, intensity * vOpacity * 0.6);
          }
        `,
        transparent: true,
        blending: THREE.NormalBlending,
        depthWrite: false,
      });

      const clouds = new THREE.Points(cloudGeometry, cloudMaterial);
      atmGroup.add(clouds);

      // Aurora simulation at magnetic poles
      const createAurora = (latitude) => {
        const auroraGeometry = new THREE.BufferGeometry();
        const auroraCount = 1000;
        const auroraPositions = new Float32Array(auroraCount * 3);
        const auroraColors = new Float32Array(auroraCount * 3);

        for (let i = 0; i < auroraCount; i++) {
          const i3 = i * 3;
          const longitude = (Math.random() - 0.5) * Math.PI * 0.3; // Limited longitude range
          const altitude = 6.371 + 0.100 + Math.random() * 0.300; // 100-400km altitude
          
          const phi = (90 - latitude) * Math.PI / 180;
          const theta = longitude;
          
          auroraPositions[i3] = altitude * Math.sin(phi) * Math.cos(theta);
          auroraPositions[i3 + 1] = altitude * Math.cos(phi);
          auroraPositions[i3 + 2] = altitude * Math.sin(phi) * Math.sin(theta);
          
          // Aurora colors (green oxygen, red nitrogen)
          const colorType = Math.random();
          if (colorType < 0.7) {
            auroraColors[i3] = 0.0; auroraColors[i3 + 1] = 1.0; auroraColors[i3 + 2] = 0.3; // Green
          } else {
            auroraColors[i3] = 1.0; auroraColors[i3 + 1] = 0.2; auroraColors[i3 + 2] = 0.2; // Red
          }
        }

        auroraGeometry.setAttribute('position', new THREE.BufferAttribute(auroraPositions, 3));
        auroraGeometry.setAttribute('color', new THREE.BufferAttribute(auroraColors, 3));

        const auroraMaterial = new THREE.ShaderMaterial({
          uniforms: { time: { value: 0 } },
          vertexShader: `
            varying vec3 vColor;
            uniform float time;
            void main() {
              vColor = color;
              vec3 pos = position;
              pos += sin(time * 2.0 + position.x * 10.0) * 0.02 * normal;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
              gl_PointSize = 3.0;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            void main() {
              float r = distance(gl_PointCoord, vec2(0.5));
              if (r > 0.5) discard;
              float intensity = 1.0 - (r * 2.0);
              gl_FragColor = vec4(vColor, intensity * 0.8);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          vertexColors: true,
        });

        return new THREE.Points(auroraGeometry, auroraMaterial);
      };

      // Add aurora at both poles
      atmGroup.add(createAurora(70));  // North
      atmGroup.add(createAurora(-70)); // South

      atmGroup.userData = { type: 'atmosphere', materials: [] };
      atmGroup.traverse(child => {
        if (child.material) atmGroup.userData.materials.push(child.material);
      });

      return atmGroup;
    };

    lodObjects.current.atmosphere = createAtmosphericDetail();
    scene.add(lodObjects.current.atmosphere);

    // ========== COSMIC MICROWAVE BACKGROUND ==========
    const createCMB = () => {
      const cmbGeometry = new THREE.SphereGeometry(1e14, 256, 256); // Observable universe radius
      const cmbMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          varying vec3 vPosition;
          varying vec2 vUv;
          void main() {
            vPosition = position;
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vPosition;
          varying vec2 vUv;
          
          // CMB temperature fluctuations (δT/T ≈ 10^-5)
          float noise3D(vec3 p) {
            return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
          }
          
          void main() {
            vec3 pos = normalize(vPosition) * 100.0;
            
            // Multi-scale noise to simulate CMB anisotropy
            float noise = 0.0;
            float amplitude = 1.0;
            float frequency = 1.0;
            
            for (int i = 0; i < 6; i++) {
              noise += amplitude * (noise3D(pos * frequency) - 0.5);
              amplitude *= 0.5;
              frequency *= 2.0;
            }
            
            // CMB base temperature: 2.725K
            float temperature = 2.725 + noise * 0.0001; // Tiny fluctuations
            
            // Blackbody radiation color approximation for 2.725K
            vec3 cmbColor = vec3(0.05, 0.02, 0.01); // Very dim red/infrared
            
            // Add slight color variation based on temperature fluctuations
            cmbColor += vec3(noise * 0.001, noise * 0.0005, 0.0);
            
            gl_FragColor = vec4(cmbColor, 1.0);
          }
        `,
        side: THREE.BackSide,
      });
      
      const cmb = new THREE.Mesh(cmbGeometry, cmbMaterial);
      cmb.userData = { type: 'cmb', material: cmbMaterial };
      return cmb;
    };

    lodObjects.current.cmb = createCMB();
    scene.add(lodObjects.current.cmb);

    // ========== MILKY WAY GALAXY (CENTER) ==========
    const createMilkyWayGalaxy = () => {
      const milkyWayGroup = new THREE.Group();
      
      // Galactic center (Sagittarius A* black hole region)
      const centerGeometry = new THREE.SphereGeometry(1000, 32, 32);
      const centerMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          varying vec3 vPosition;
          void main() {
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec3 vPosition;
          void main() {
            float dist = length(vPosition);
            float intensity = 1.0 - smoothstep(0.0, 1000.0, dist);
            vec3 color = mix(vec3(1.0, 0.8, 0.4), vec3(1.0, 0.3, 0.1), intensity);
            gl_FragColor = vec4(color, intensity);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
      });
      
      const galacticCenter = new THREE.Mesh(centerGeometry, centerMaterial);
      milkyWayGroup.add(galacticCenter);
      
      // Milky Way spiral arms with 400 billion stars
      const armGeometry = new THREE.BufferGeometry();
      const starCount = 100000; // Representing 400 billion stars
      const armPositions = new Float32Array(starCount * 3);
      const armColors = new Float32Array(starCount * 3);
      const armSizes = new Float32Array(starCount);
      
      // Spiral arm parameters (based on Milky Way structure)
      const arms = [
        { name: 'Perseus', angle: 0, stars: 25000 },
        { name: 'Sagittarius', angle: Math.PI * 0.5, stars: 25000 },
        { name: 'Centaurus', angle: Math.PI, stars: 25000 },
        { name: 'Norma', angle: Math.PI * 1.5, stars: 25000 },
      ];
      
      let starIndex = 0;
      arms.forEach(arm => {
        for (let i = 0; i < arm.stars; i++) {
          const i3 = starIndex * 3;
          
          // Logarithmic spiral with realistic parameters
          const t = (i / arm.stars) * 4 * Math.PI; // 4 full rotations
          const radius = 2000 + t * 8000; // 2,000 to 50,000 ly radius
          const spiralAngle = arm.angle + t * 0.2; // Spiral tightness
          
          // Add random scatter and spiral arm structure
          const scatter = (Math.random() - 0.5) * 5000;
          const heightScatter = (Math.random() - 0.5) * 1000; // Thin disk
          
          armPositions[i3] = (radius + scatter) * Math.cos(spiralAngle);
          armPositions[i3 + 1] = heightScatter;
          armPositions[i3 + 2] = (radius + scatter) * Math.sin(spiralAngle);
          
          // Star population types and colors
          const distanceFromCenter = radius;
          const populationType = Math.random();
          
          if (distanceFromCenter < 10000) {
            // Population II stars (older, redder) in bulge
            armColors[i3] = 1.0;
            armColors[i3 + 1] = 0.7;
            armColors[i3 + 2] = 0.4;
          } else if (populationType < 0.1) {
            // Blue giants in spiral arms
            armColors[i3] = 0.7;
            armColors[i3 + 1] = 0.8;
            armColors[i3 + 2] = 1.0;
          } else if (populationType < 0.8) {
            // Main sequence stars (like our Sun)
            armColors[i3] = 1.0;
            armColors[i3 + 1] = 1.0;
            armColors[i3 + 2] = 0.9;
          } else {
            // Red giants
            armColors[i3] = 1.0;
            armColors[i3 + 1] = 0.6;
            armColors[i3 + 2] = 0.3;
          }
          
          armSizes[i] = Math.random() * 2 + 0.5;
          starIndex++;
        }
      });
      
      armGeometry.setAttribute('position', new THREE.BufferAttribute(armPositions, 3));
      armGeometry.setAttribute('color', new THREE.BufferAttribute(armColors, 3));
      armGeometry.setAttribute('size', new THREE.BufferAttribute(armSizes, 1));
      
      const armMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          uniform float time;
          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            
            // Gentle rotation of galaxy
            vec3 pos = position;
            float rotation = time * 0.001; // Very slow galactic rotation
            float cosR = cos(rotation);
            float sinR = sin(rotation);
            pos.x = position.x * cosR - position.z * sinR;
            pos.z = position.x * sinR + position.z * cosR;
            
            gl_PointSize = size * (50000.0 / -mvPosition.z);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            float intensity = 1.0 - (r * 2.0);
            intensity = pow(intensity, 2.0);
            gl_FragColor = vec4(vColor * intensity, intensity);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
      });
      
      const spiralArms = new THREE.Points(armGeometry, armMaterial);
      milkyWayGroup.add(spiralArms);
      
      milkyWayGroup.userData = { 
        type: 'milky_way',
        materials: [centerMaterial, armMaterial]
      };
      
      return milkyWayGroup;
    };

    // Create Milky Way at center
    const milkyWay = createMilkyWayGalaxy();
    scene.add(milkyWay);

    // ========== AESTHETIC VFX SYSTEM ==========
    const vfxSystem = {
      spaceDust: null,
      cosmicRays: null,
      starfield: null,
      lensFlares: [],
    };

    // ========== SPACE DUST PARTICLES ==========
    const createSpaceDust = () => {
      const dustGeometry = new THREE.BufferGeometry();
      const dustCount = 50000;
      const dustPositions = new Float32Array(dustCount * 3);
      const dustVelocities = new Float32Array(dustCount * 3);
      const dustSizes = new Float32Array(dustCount);
      const dustOpacities = new Float32Array(dustCount);

      for (let i = 0; i < dustCount; i++) {
        const i3 = i * 3;
        
        // Distribute dust in large sphere around camera
        const phi = Math.random() * Math.PI * 2;
        const cosTheta = 2 * Math.random() - 1;
        const u = Math.random();
        const theta = Math.acos(cosTheta);
        const r = 10000 + Math.cbrt(u) * 500000; // 10k to 500k ly
        
        dustPositions[i3] = r * Math.sin(theta) * Math.cos(phi);
        dustPositions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
        dustPositions[i3 + 2] = r * Math.cos(theta);
        
        // Dust motion vectors
        dustVelocities[i3] = (Math.random() - 0.5) * 0.1;
        dustVelocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
        dustVelocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
        
        dustSizes[i] = Math.random() * 2 + 0.5;
        dustOpacities[i] = Math.random() * 0.3 + 0.1;
      }

      dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
      dustGeometry.setAttribute('velocity', new THREE.BufferAttribute(dustVelocities, 3));
      dustGeometry.setAttribute('size', new THREE.BufferAttribute(dustSizes, 1));
      dustGeometry.setAttribute('opacity', new THREE.BufferAttribute(dustOpacities, 1));

      const dustMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          cameraPosition: { value: new THREE.Vector3() },
        },
        vertexShader: `
          attribute float size;
          attribute float opacity;
          attribute vec3 velocity;
          varying float vOpacity;
          varying float vDistance;
          uniform float time;
          uniform vec3 cameraPosition;
          
          void main() {
            vOpacity = opacity;
            
            // Animate dust particles
            vec3 pos = position + velocity * time * 0.1;
            
            // Calculate distance fade
            float dist = distance(pos, cameraPosition);
            vDistance = dist;
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (10000.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying float vOpacity;
          varying float vDistance;
          
          void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            
            float intensity = 1.0 - (r * 2.0);
            intensity = pow(intensity, 2.0);
            
            // Distance-based opacity
            float distanceFade = 1.0 - smoothstep(50000.0, 500000.0, vDistance);
            
            vec3 dustColor = vec3(0.8, 0.9, 1.0); // Blueish space dust
            gl_FragColor = vec4(dustColor, intensity * vOpacity * distanceFade * 0.6);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      return new THREE.Points(dustGeometry, dustMaterial);
    };

    // ========== COSMIC RAYS ==========
    const createCosmicRays = () => {
      const rayGeometry = new THREE.BufferGeometry();
      const rayCount = 1000;
      const rayPositions = new Float32Array(rayCount * 6); // 2 points per line
      const rayColors = new Float32Array(rayCount * 6);

      for (let i = 0; i < rayCount; i++) {
        const i6 = i * 6;
        
        // Random ray direction
        const phi = Math.random() * Math.PI * 2;
        const cosTheta = 2 * Math.random() - 1;
        const theta = Math.acos(cosTheta);
        
        const direction = new THREE.Vector3(
          Math.sin(theta) * Math.cos(phi),
          Math.sin(theta) * Math.sin(phi),
          Math.cos(theta)
        );
        
        // Ray start point (far away)
        const startDistance = 100000 + Math.random() * 200000;
        const start = direction.clone().multiplyScalar(-startDistance);
        
        // Ray end point
        const rayLength = 50000 + Math.random() * 100000;
        const end = start.clone().add(direction.clone().multiplyScalar(rayLength));
        
        // Set positions
        rayPositions[i6] = start.x;
        rayPositions[i6 + 1] = start.y;
        rayPositions[i6 + 2] = start.z;
        rayPositions[i6 + 3] = end.x;
        rayPositions[i6 + 4] = end.y;
        rayPositions[i6 + 5] = end.z;
        
        // Cosmic ray colors (high energy particles)
        const energy = Math.random();
        rayColors[i6] = energy; // Start
        rayColors[i6 + 1] = energy * 0.8;
        rayColors[i6 + 2] = 1.0;
        rayColors[i6 + 3] = 0.0; // End (fade)
        rayColors[i6 + 4] = 0.0;
        rayColors[i6 + 5] = 0.0;
      }

      rayGeometry.setAttribute('position', new THREE.BufferAttribute(rayPositions, 3));
      rayGeometry.setAttribute('color', new THREE.BufferAttribute(rayColors, 3));

      const rayMaterial = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending,
      });

      return new THREE.LineSegments(rayGeometry, rayMaterial);
    };

    // ========== ENHANCED STARFIELD ==========
    const createEnhancedStarfield = () => {
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 200000;
      const starPositions = new Float32Array(starCount * 3);
      const starColors = new Float32Array(starCount * 3);
      const starSizes = new Float32Array(starCount);
      const starTwinkle = new Float32Array(starCount);

      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        
        // Distribute stars in massive sphere
        const phi = Math.random() * Math.PI * 2;
        const cosTheta = 2 * Math.random() - 1;
        const u = Math.random();
        const theta = Math.acos(cosTheta);
        const r = 1000000 + Math.cbrt(u) * 10000000000; // 1M to 10B ly
        
        starPositions[i3] = r * Math.sin(theta) * Math.cos(phi);
        starPositions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
        starPositions[i3 + 2] = r * Math.cos(theta);
        
        // Star type and color
        const starType = Math.random();
        if (starType < 0.05) {
          // Blue giants
          starColors[i3] = 0.7;
          starColors[i3 + 1] = 0.8;
          starColors[i3 + 2] = 1.0;
          starSizes[i] = Math.random() * 3 + 2;
        } else if (starType < 0.15) {
          // White stars
          starColors[i3] = 1.0;
          starColors[i3 + 1] = 1.0;
          starColors[i3 + 2] = 1.0;
          starSizes[i] = Math.random() * 2 + 1.5;
        } else if (starType < 0.4) {
          // Yellow stars (like Sun)
          starColors[i3] = 1.0;
          starColors[i3 + 1] = 0.9;
          starColors[i3 + 2] = 0.7;
          starSizes[i] = Math.random() * 1.5 + 1;
        } else {
          // Red dwarfs
          starColors[i3] = 1.0;
          starColors[i3 + 1] = 0.6;
          starColors[i3 + 2] = 0.4;
          starSizes[i] = Math.random() * 1 + 0.5;
        }
        
        starTwinkle[i] = Math.random() * Math.PI * 2;
      }

      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
      starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
      starGeometry.setAttribute('twinkle', new THREE.BufferAttribute(starTwinkle, 1));

      const starMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          cameraPosition: { value: new THREE.Vector3() },
        },
        vertexShader: `
          attribute float size;
          attribute float twinkle;
          varying vec3 vColor;
          varying float vTwinkle;
          uniform float time;
          uniform vec3 cameraPosition;
          
          void main() {
            vColor = color;
            vTwinkle = sin(time * 2.0 + twinkle) * 0.3 + 0.7;
            
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * vTwinkle * (500000.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying float vTwinkle;
          
          void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            
            // Create star spikes
            float spike1 = abs(gl_PointCoord.x - 0.5);
            float spike2 = abs(gl_PointCoord.y - 0.5);
            float spikes = max(1.0 - spike1 * 8.0, 1.0 - spike2 * 8.0);
            
            float intensity = 1.0 - (r * 2.0);
            intensity = pow(intensity, 1.5);
            intensity = max(intensity, spikes * 0.3);
            
            gl_FragColor = vec4(vColor * intensity * vTwinkle, intensity * vTwinkle);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
        depthWrite: false,
      });

      return new THREE.Points(starGeometry, starMaterial);
    };

    // Create VFX elements
    vfxSystem.spaceDust = createSpaceDust();
    vfxSystem.cosmicRays = createCosmicRays();
    vfxSystem.starfield = createEnhancedStarfield();
    
    scene.add(vfxSystem.spaceDust);
    scene.add(vfxSystem.cosmicRays);
    scene.add(vfxSystem.starfield);

    // ========== UNIVERSAL GALAXY SYSTEM ==========
    const universeSystem = {
      galaxies: new Map(), // Store all galaxies
      loadedGalaxies: new Set(), // Track which galaxies have detailed systems
      loadedStars: new Map(), // Track loaded stellar systems
      loadedPlanets: new Map(), // Track loaded planetary systems
      
      // O(1) distance checking
      checkDistance: (position, targetPosition, threshold) => {
        const dx = position.x - targetPosition.x;
        const dy = position.y - targetPosition.y;
        const dz = position.z - targetPosition.z;
        return (dx * dx + dy * dy + dz * dz) < (threshold * threshold);
      }
    };

    // ========== PROCEDURAL GALAXY GENERATOR ==========
    const createUniverseGalaxies = () => {
      const galaxyTypes = [
        { type: 'spiral', probability: 0.6, starCount: 100000 },
        { type: 'elliptical', probability: 0.3, starCount: 1000000 },
        { type: 'irregular', probability: 0.1, starCount: 10000 }
      ];

      // Generate 10,000 galaxies throughout observable universe
      for (let i = 0; i < 10000; i++) {
        const galaxyId = `galaxy_${i}`;
        
        // Distribute galaxies in observable universe (13.8 billion ly radius)
        const phi = Math.random() * Math.PI * 2;
        const cosTheta = 2 * Math.random() - 1;
        const u = Math.random();
        const theta = Math.acos(cosTheta);
        const r = 1000000 + Math.cbrt(u) * 12000000000; // 1M to 12B ly from center
        
        const x = r * Math.sin(theta) * Math.cos(phi);
        const y = r * Math.sin(theta) * Math.sin(phi);
        const z = r * Math.cos(theta);
        
        // Determine galaxy type
        const rand = Math.random();
        let galaxyType = galaxyTypes[2]; // default irregular
        let cumulative = 0;
        for (const type of galaxyTypes) {
          cumulative += type.probability;
          if (rand < cumulative) {
            galaxyType = type;
            break;
          }
        }
        
        const galaxyData = {
          id: galaxyId,
          position: new THREE.Vector3(x, y, z),
          type: galaxyType.type,
          starCount: galaxyType.starCount * (0.5 + Math.random()), // Vary size
          age: 1 + Math.random() * 12, // 1-13 billion years
          metallicity: Math.random(), // Heavy element content
          isLoaded: false,
          stars: new Map(),
          mesh: null
        };
        
        universeSystem.galaxies.set(galaxyId, galaxyData);
      }
      
      console.log(`Generated ${universeSystem.galaxies.size} galaxies throughout the universe`);
    };

    // ========== PROCEDURAL STELLAR SYSTEM GENERATOR ==========
    const generateStellarSystem = (starId, starPosition, starType) => {
      const systemData = {
        id: starId,
        position: starPosition.clone(),
        starType: starType,
        planets: [],
        asteroidBelts: [],
        comets: []
      };
      
      // Generate planets based on star type
      const planetCount = starType === 'M' ? 2 + Math.random() * 4 : // Red dwarf: 2-6 planets
                         starType === 'K' ? 3 + Math.random() * 5 : // Orange: 3-8 planets  
                         starType === 'G' ? 4 + Math.random() * 6 : // Sun-like: 4-10 planets
                         starType === 'F' ? 2 + Math.random() * 4 : // Hot: 2-6 planets
                         1 + Math.random() * 3; // Hot stars: 1-4 planets
      
      for (let p = 0; p < planetCount; p++) {
        const planetId = `${starId}_planet_${p}`;
        const distance = (p + 1) * (20 + Math.random() * 100); // AU equivalent
        const radius = 0.5 + Math.random() * 10; // Planet radius
        const planetType = distance < 50 ? 'terrestrial' : 
                          distance < 200 ? (Math.random() > 0.5 ? 'gas_giant' : 'terrestrial') : 
                          'ice_giant';
        
        const planetData = {
          id: planetId,
          parentStar: starId,
          distance: distance,
          radius: radius,
          type: planetType,
          moons: [],
          hasLife: planetType === 'terrestrial' && distance > 30 && distance < 150 && Math.random() < 0.01,
          composition: planetType,
          temperature: 300 - (distance * 2) + (Math.random() - 0.5) * 100
        };
        
        // Generate moons for larger planets
        if (radius > 3) {
          const moonCount = Math.floor(Math.random() * 5);
          for (let m = 0; m < moonCount; m++) {
            planetData.moons.push({
              id: `${planetId}_moon_${m}`,
              distance: radius * 2 + m * 5,
              radius: 0.1 + Math.random() * 0.5,
              type: 'rocky'
            });
          }
        }
        
        systemData.planets.push(planetData);
      }
      
      // Generate asteroid belt
      if (Math.random() > 0.3) {
        systemData.asteroidBelts.push({
          innerRadius: 150 + Math.random() * 50,
          outerRadius: 200 + Math.random() * 100,
          density: Math.random() * 1000
        });
      }
      
      return systemData;
    };

    // ========== O(1) DYNAMIC LOADING SYSTEM ==========
    const updateUniverseDetails = (cameraPosition) => {
      const GALAXY_DETAIL_DISTANCE = 5000000; // 5M ly - load galaxy details
      const STAR_DETAIL_DISTANCE = 1000; // 1000 ly - load stellar systems  
      const PLANET_DETAIL_DISTANCE = 100; // 100 ly - load planetary details
      
      // Check galaxies for detail loading
      universeSystem.galaxies.forEach((galaxy, galaxyId) => {
        const isClose = universeSystem.checkDistance(cameraPosition, galaxy.position, GALAXY_DETAIL_DISTANCE);
        
        if (isClose && !galaxy.isLoaded) {
          // Load galaxy stellar systems
          console.log(`Loading detailed systems for ${galaxyId}`);
          
          for (let s = 0; s < Math.min(galaxy.starCount, 1000); s++) { // Limit for performance
            const starId = `${galaxyId}_star_${s}`;
            
            // Generate star position within galaxy
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 50000; // 50,000 ly galaxy radius
            const height = (Math.random() - 0.5) * 1000; // Thin disk
            
            const starPos = galaxy.position.clone().add(new THREE.Vector3(
              radius * Math.cos(angle),
              height,
              radius * Math.sin(angle)
            ));
            
            // Determine star type (based on stellar population)
            const starTypes = ['M', 'K', 'G', 'F', 'A', 'B', 'O'];
            const probabilities = [0.75, 0.12, 0.08, 0.03, 0.006, 0.0013, 0.00003];
            let starType = 'M';
            const rand = Math.random();
            let cumulative = 0;
            for (let i = 0; i < starTypes.length; i++) {
              cumulative += probabilities[i];
              if (rand < cumulative) {
                starType = starTypes[i];
                break;
              }
            }
            
            // Generate stellar system
            const stellarSystem = generateStellarSystem(starId, starPos, starType);
            galaxy.stars.set(starId, stellarSystem);
          }
          
          galaxy.isLoaded = true;
          universeSystem.loadedGalaxies.add(galaxyId);
        }
        
        else if (!isClose && galaxy.isLoaded) {
          // Unload galaxy details to save memory
          galaxy.stars.clear();
          galaxy.isLoaded = false;
          universeSystem.loadedGalaxies.delete(galaxyId);
          console.log(`Unloaded ${galaxyId} to save memory`);
        }
      });
      
      // Check loaded galaxies for stellar system details
      universeSystem.loadedGalaxies.forEach(galaxyId => {
        const galaxy = universeSystem.galaxies.get(galaxyId);
        
        galaxy.stars.forEach((stellarSystem, starId) => {
          const isStarClose = universeSystem.checkDistance(cameraPosition, stellarSystem.position, STAR_DETAIL_DISTANCE);
          
          if (isStarClose && !universeSystem.loadedStars.has(starId)) {
            // Create visible stellar system objects
            console.log(`Loading stellar system: ${starId}`);
            universeSystem.loadedStars.set(starId, stellarSystem);
            
            // Check for planetary details
            stellarSystem.planets.forEach(planet => {
              const planetWorldPos = stellarSystem.position.clone().add(
                new THREE.Vector3(planet.distance, 0, 0)
              );
              
              const isPlanetClose = universeSystem.checkDistance(cameraPosition, planetWorldPos, PLANET_DETAIL_DISTANCE);
              
              if (isPlanetClose && !universeSystem.loadedPlanets.has(planet.id)) {
                console.log(`Loading planetary system: ${planet.id}`);
                universeSystem.loadedPlanets.set(planet.id, planet);
              }
            });
          }
          
          else if (!isStarClose && universeSystem.loadedStars.has(starId)) {
            // Unload stellar system
            universeSystem.loadedStars.delete(starId);
            
            // Unload associated planets
            stellarSystem.planets.forEach(planet => {
              universeSystem.loadedPlanets.delete(planet.id);
            });
          }
        });
      });
    };

    // Initialize universe
    createUniverseGalaxies();

    // Define the manual exit function with access to scene
    exitPlanetMode.current = () => {
      if (planetarySystem.current.isInsidePlanet) {
        planetarySystem.current.isInsidePlanet = false;
        planetarySystem.current.lockedToSurface = false;
        
        // Remove detailed surface objects
        if (lodObjects.current.planetary) {
          scene.remove(lodObjects.current.planetary);
          lodObjects.current.planetary = null;
        }
        if (planetarySystem.current.skybox) {
          scene.remove(planetarySystem.current.skybox);
          planetarySystem.current.skybox = null;
        }
        
        // Move camera away from planet surface
        if (planetarySystem.current.currentPlanet) {
          const planet = planetarySystem.current.currentPlanet;
          const awayDirection = cameraState.current.position.clone()
            .sub(planet.position)
            .normalize();
          const newPosition = planet.position.clone()
            .add(awayDirection.multiplyScalar(planet.userData.radius * 1.5));
          
          cameraState.current.position.copy(newPosition);
          cameraState.current.velocity.set(0, 0, 0); // Stop movement
        }
        
        console.log(`Manually exited planet: ${planetarySystem.current.currentPlanet?.userData.name}`);
        planetarySystem.current.currentPlanet = null;
        
        // Reset LOD level
        cameraState.current.lastLodLevel = -1;
      }
    };

    // ========== DETAILED PLANETARY SURFACE ==========
    const createPlanetarySurface = (planetData) => {
      const surfaceGroup = new THREE.Group();
      
      // High-resolution planet geometry
      const planetGeometry = new THREE.IcosahedronGeometry(planetData.radius, 6); // High detail
      
      // Realistic Earth-like terrain shader
      const planetMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          sunPosition: { value: new THREE.Vector3(100, 50, 0) },
          oceanLevel: { value: planetData.radius * 0.99 },
        },
        vertexShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          varying vec3 vWorldPosition;
          uniform float time;
          
          // Noise functions for terrain generation
          float noise(vec3 p) {
            return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
          }
          
          float fbm(vec3 p) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            
            for (int i = 0; i < 6; i++) {
              value += amplitude * (noise(p * frequency) - 0.5);
              amplitude *= 0.5;
              frequency *= 2.0;
            }
            return value;
          }
          
          void main() {
            vPosition = position;
            vNormal = normal;
            
            // Generate terrain height based on noise
            float terrainHeight = fbm(position * 0.5) * 0.1;
            vec3 displacedPosition = position + normal * terrainHeight;
            
            vWorldPosition = (modelMatrix * vec4(displacedPosition, 1.0)).xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          varying vec3 vWorldPosition;
          uniform float time;
          uniform vec3 sunPosition;
          uniform float oceanLevel;
          
          // Noise function
          float noise(vec3 p) {
            return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
          }
          
          void main() {
            float altitude = length(vWorldPosition);
            vec3 normal = normalize(vNormal);
            
            // Terrain types based on height and noise
            float terrainNoise = noise(vPosition * 10.0);
            float temperatureZone = abs(vPosition.y / length(vPosition)); // Latitude-based
            
            vec3 color;
            
            // Ocean (below ocean level)
            if (altitude < oceanLevel) {
              color = mix(vec3(0.0, 0.1, 0.3), vec3(0.0, 0.3, 0.6), terrainNoise);
            }
            // Beach/coast
            else if (altitude < oceanLevel * 1.002) {
              color = vec3(0.8, 0.7, 0.5); // Sandy beach
            }
            // Land based on latitude and noise
            else {
              if (temperatureZone > 0.8) {
                // Polar regions - ice/snow
                color = vec3(0.9, 0.95, 1.0);
              } else if (temperatureZone > 0.6) {
                // Temperate - forests/grasslands
                color = mix(vec3(0.2, 0.5, 0.1), vec3(0.6, 0.4, 0.2), terrainNoise);
              } else if (temperatureZone > 0.3) {
                // Subtropical - varied terrain
                color = mix(vec3(0.4, 0.6, 0.2), vec3(0.7, 0.5, 0.3), terrainNoise);
              } else {
                // Tropical/equatorial - jungles and deserts
                if (terrainNoise > 0.6) {
                  color = vec3(0.8, 0.6, 0.3); // Desert
                } else {
                  color = vec3(0.1, 0.4, 0.1); // Jungle
                }
              }
            }
            
            // Lighting calculation
            vec3 lightDir = normalize(sunPosition - vWorldPosition);
            float lightIntensity = max(0.2, dot(normal, lightDir));
            
            // Add some atmospheric perspective
            float distance = length(vWorldPosition);
            float atmosphere = exp(-distance * 0.0001);
            
            color *= lightIntensity * atmosphere;
            
            gl_FragColor = vec4(color, 1.0);
          }
        `,
      });
      
      const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
      surfaceGroup.add(planetMesh);
      
      // Add detailed features
      // Cities (lights on night side)
      const cityGeometry = new THREE.BufferGeometry();
      const cityCount = 1000;
      const cityPositions = new Float32Array(cityCount * 3);
      const cityColors = new Float32Array(cityCount * 3);
      
      for (let i = 0; i < cityCount; i++) {
        const i3 = i * 3;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = planetData.radius * 1.001; // Slightly above surface
        
        cityPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        cityPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        cityPositions[i3 + 2] = radius * Math.cos(phi);
        
        // City light colors
        cityColors[i3] = 1.0;     // R
        cityColors[i3 + 1] = 0.8; // G  
        cityColors[i3 + 2] = 0.4; // B - warm city lights
      }
      
      cityGeometry.setAttribute('position', new THREE.BufferAttribute(cityPositions, 3));
      cityGeometry.setAttribute('color', new THREE.BufferAttribute(cityColors, 3));
      
      const cityMaterial = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
      });
      
      const cities = new THREE.Points(cityGeometry, cityMaterial);
      surfaceGroup.add(cities);
      
      surfaceGroup.userData = { 
        type: 'planetary_surface', 
        planetData: planetData,
        materials: [planetMaterial]
      };
      
      return surfaceGroup;
    };

    // ========== PLANETARY SKY SYSTEM ==========
    const createPlanetarySky = (planetData) => {
      const skyGroup = new THREE.Group();
      
      // Sky dome for surface view
      const skyGeometry = new THREE.SphereGeometry(1000, 64, 64);
      const skyMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          sunPosition: { value: new THREE.Vector3(100, 50, 0) },
          planetPosition: { value: new THREE.Vector3(0, 0, 0) },
        },
        vertexShader: `
          varying vec3 vPosition;
          varying vec3 vWorldPosition;
          void main() {
            vPosition = position;
            vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vPosition;
          varying vec3 vWorldPosition;
          uniform float time;
          uniform vec3 sunPosition;
          uniform vec3 planetPosition;
          
          void main() {
            vec3 direction = normalize(vPosition);
            
            // Sky color based on direction and sun position
            vec3 sunDir = normalize(sunPosition - planetPosition);
            float sunDot = dot(direction, sunDir);
            
            // Atmospheric scattering simulation
            float altitude = direction.y;
            vec3 skyColor;
            
            if (altitude > 0.0) {
              // Day sky
              vec3 dayColor = vec3(0.5, 0.7, 1.0);
              vec3 sunColor = vec3(1.0, 0.9, 0.7);
              
              // Sun intensity
              float sunIntensity = pow(max(0.0, sunDot), 32.0);
              
              // Horizon effect
              float horizonFade = pow(altitude, 0.5);
              
              skyColor = mix(vec3(1.0, 0.8, 0.6), dayColor, horizonFade);
              skyColor += sunColor * sunIntensity;
            } else {
              // Below horizon - darker
              skyColor = vec3(0.1, 0.1, 0.2);
            }
            
            gl_FragColor = vec4(skyColor, 1.0);
          }
        `,
        side: THREE.BackSide,
      });
      
      const skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
      skyGroup.add(skyDome);
      
      // Add visible stars in the sky
      const starFieldGeometry = new THREE.BufferGeometry();
      const starCount = 5000;
      const starPositions = new Float32Array(starCount * 3);
      const starColors = new Float32Array(starCount * 3);
      const starSizes = new Float32Array(starCount);
      
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = 500; // Stars on sky dome
        
        starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        starPositions[i3 + 2] = radius * Math.cos(phi);
        
        // Star colors (different stellar types)
        const starType = Math.random();
        if (starType > 0.7) {
          starColors[i3] = 0.8; starColors[i3 + 1] = 0.9; starColors[i3 + 2] = 1.0; // Blue
        } else if (starType > 0.4) {
          starColors[i3] = 1.0; starColors[i3 + 1] = 1.0; starColors[i3 + 2] = 1.0; // White
        } else {
          starColors[i3] = 1.0; starColors[i3 + 1] = 0.8; starColors[i3 + 2] = 0.6; // Yellow/Red
        }
        
        starSizes[i] = Math.random() * 3 + 1;
      }
      
      starFieldGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      starFieldGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
      starFieldGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
      
      const starFieldMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          sunPosition: { value: new THREE.Vector3(100, 50, 0) },
        },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          varying float vVisibility;
          uniform float time;
          uniform vec3 sunPosition;
          
          void main() {
            vColor = color;
            
            // Stars only visible when sun is down (simple day/night)
            vec3 sunDir = normalize(sunPosition);
            float dayFactor = max(0.0, sunDir.y);
            vVisibility = 1.0 - dayFactor;
            
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (100.0 / -mvPosition.z) * vVisibility;
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying float vVisibility;
          
          void main() {
            if (vVisibility < 0.1) discard;
            
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            
            float intensity = 1.0 - (r * 2.0);
            intensity = pow(intensity, 2.0);
            
            gl_FragColor = vec4(vColor * intensity, intensity * vVisibility);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
      });
      
      const starField = new THREE.Points(starFieldGeometry, starFieldMaterial);
      skyGroup.add(starField);
      
      skyGroup.userData = { 
        type: 'planetary_sky',
        materials: [skyMaterial, starFieldMaterial]
      };
      
      return skyGroup;
    };

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.5;
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Lights
    const ambientLight = new THREE.AmbientLight(0x0a0a2a, 0.5);
    scene.add(ambientLight);

    // Directional lights for cinematic effect
    const rimLight1 = new THREE.DirectionalLight(0x4488ff, 0.5);
    rimLight1.position.set(-100, 50, -100);
    scene.add(rimLight1);

    const rimLight2 = new THREE.DirectionalLight(0xff8844, 0.3);
    rimLight2.position.set(100, -50, 100);
    scene.add(rimLight2);

    // ========== SUN WITH DETAILS ==========
    const sunGeometry = new THREE.IcosahedronGeometry(20, 4);
    const sunMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        detail: { value: 1.0 },
      },
      vertexShader: `
        varying vec3 vPosition;
        varying vec3 vNormal;
        uniform float time;
        
        void main() {
          vPosition = position;
          vNormal = normal;
          
          vec3 pos = position;
          float noise = sin(position.x * 0.3 + time) * cos(position.y * 0.3 - time * 0.8) * 0.5;
          pos += normal * noise;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float detail;
        varying vec3 vPosition;
        varying vec3 vNormal;
        
        void main() {
          vec3 color = vec3(1.0, 0.9, 0.0);
          float pattern = sin(vPosition.x * detail) * cos(vPosition.y * detail) * sin(vPosition.z * detail + time);
          color += vec3(0.2, 0.1, 0.0) * pattern;
          
          float glow = pow(0.8 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
          color += vec3(1.0, 0.5, 0.0) * glow;
          
          gl_FragColor = vec4(color, 1.0);
        }
      `,
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);

    // Sun glow
    const sunGlowGeometry = new THREE.SphereGeometry(30, 32, 32);
    const sunGlowMaterial = new THREE.ShaderMaterial({
      uniforms: {
        viewVector: { value: new THREE.Vector3() },
      },
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        void main() {
          float intensity = pow(0.8 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
          gl_FragColor = vec4(1.0, 0.8, 0.3, 1.0) * intensity;
        }
      `,
      side: THREE.BackSide,
      blending: THREE.AdditiveBlending,
      transparent: true,
    });
    const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
    sun.add(sunGlow);

    // Sun light
    const sunLight = new THREE.PointLight(0xffffff, 2, 1000);
    sun.add(sunLight);

    // ========== REAL NASA SOLAR SYSTEM DATA ==========
    const planets = [];
    
    // Real Solar System data from NASA/JPL (distances in AU, radii in km, orbital periods in Earth years)
    const realSolarSystemData = [
      {
        name: "Mercury",
        radius: 2439.7,        // km - Real radius
        distance: 0.387,       // AU - Real semi-major axis
        orbitalPeriod: 0.241,  // Earth years
        rotationPeriod: 58.646, // Earth days
        mass: 3.3011e23,       // kg
        density: 5.427,        // g/cm³
        temperature: { min: -173, max: 427 }, // °C
        color: 0x8C7853,       // Mercury's actual color
        atmosphere: { pressure: 0, composition: "None" },
        moons: [],
        detail: 3,
        hasRings: false,
        discovery: "Ancient",
        physicalCharacteristics: {
          magneticField: 1.1, // % of Earth's
          surfaceGravity: 3.7, // m/s²
          escapeVelocity: 4.25, // km/s
          albedo: 0.119
        }
      },
      {
        name: "Venus",
        radius: 6051.8,
        distance: 0.723,
        orbitalPeriod: 0.615,
        rotationPeriod: -243.025, // Retrograde rotation
        mass: 4.8675e24,
        density: 5.243,
        temperature: { min: 462, max: 464 },
        color: 0xFFC649,
        atmosphere: { 
          pressure: 92, // bars
          composition: "96.5% CO₂, 3.5% N₂" 
        },
        moons: [],
        detail: 4,
        hasRings: false,
        discovery: "Ancient",
        physicalCharacteristics: {
          magneticField: 0,
          surfaceGravity: 8.87,
          escapeVelocity: 10.36,
          albedo: 0.689
        }
      },
      {
        name: "Earth",
        radius: 6371.0,
        distance: 1.0,
        orbitalPeriod: 1.0,
        rotationPeriod: 1.0,
        mass: 5.9724e24,
        density: 5.514,
        temperature: { min: -89, max: 57 },
        color: 0x6B93D6,
        atmosphere: { 
          pressure: 1.013, 
          composition: "78% N₂, 21% O₂, 1% Ar+trace gases" 
        },
        moons: [
          {
            name: "Moon",
            radius: 1737.4,
            distance: 0.00257, // AU from Earth
            mass: 7.342e22,
            orbitalPeriod: 27.3, // days
            color: 0xC8C8C8
          }
        ],
        detail: 5,
        hasRings: false,
        discovery: "N/A",
        physicalCharacteristics: {
          magneticField: 100,
          surfaceGravity: 9.807,
          escapeVelocity: 11.186,
          albedo: 0.306
        },
        biosphere: {
          hasLife: true,
          biodiversityIndex: 1.0,
          biomass: "550 billion tons carbon"
        }
      },
      {
        name: "Mars",
        radius: 3389.5,
        distance: 1.524,
        orbitalPeriod: 1.881,
        rotationPeriod: 1.026,
        mass: 6.4171e23,
        density: 3.9335,
        temperature: { min: -87, max: -5 },
        color: 0xCD5C5C,
        atmosphere: { 
          pressure: 0.006, 
          composition: "95% CO₂, 3% N₂, 1.6% Ar" 
        },
        moons: [
          {
            name: "Phobos",
            radius: 11.3,
            distance: 0.0000627, // AU
            mass: 1.0659e16,
            orbitalPeriod: 0.32, // days
            color: 0x8C7853
          },
          {
            name: "Deimos", 
            radius: 6.2,
            distance: 0.000157,
            mass: 1.4762e15,
            orbitalPeriod: 1.26,
            color: 0x8C7853
          }
        ],
        detail: 4,
        hasRings: false,
        discovery: "Ancient",
        physicalCharacteristics: {
          magneticField: 0,
          surfaceGravity: 3.711,
          escapeVelocity: 5.027,
          albedo: 0.25
        },
        exploration: {
          missions: ["Viking", "Pathfinder", "Spirit", "Opportunity", "Curiosity", "Perseverance"],
          hasWater: true,
          potentialLife: "Possible"
        }
      },
      {
        name: "Jupiter",
        radius: 69911,
        distance: 5.204,
        orbitalPeriod: 11.862,
        rotationPeriod: 0.414, // 9.9 hours
        mass: 1.8982e27,
        density: 1.326,
        temperature: { min: -145, max: -108 },
        color: 0xFFB366,
        atmosphere: { 
          pressure: 1000, // bars at 1 bar level
          composition: "89% H₂, 10% He, 1% CH₄+NH₃+trace" 
        },
        moons: [
          {
            name: "Io",
            radius: 1821.6,
            distance: 0.00282,
            mass: 8.932e22,
            orbitalPeriod: 1.77,
            color: 0xFFFF99,
            volcanicallyActive: true
          },
          {
            name: "Europa",
            radius: 1560.8,
            distance: 0.00449,
            mass: 4.8e22,
            orbitalPeriod: 3.55,
            color: 0xAAFFFF,
            hasSubsurfaceOcean: true
          },
          {
            name: "Ganymede",
            radius: 2634.1,
            distance: 0.00716,
            mass: 1.482e23,
            orbitalPeriod: 7.15,
            color: 0xAA8855,
            hasOwnMagnetosphere: true
          },
          {
            name: "Callisto",
            radius: 2410.3,
            distance: 0.01258,
            mass: 1.076e23,
            orbitalPeriod: 16.69,
            color: 0x665544
          }
        ],
        detail: 4,
        hasRings: true,
        discovery: "Ancient",
        physicalCharacteristics: {
          magneticField: 20000, // % of Earth's
          surfaceGravity: 24.79,
          escapeVelocity: 59.5,
          albedo: 0.343
        },
        greatRedSpot: {
          present: true,
          diameter: 16350, // km
          windSpeed: 432 // km/h
        }
      },
      {
        name: "Saturn",
        radius: 58232,
        distance: 9.573,
        orbitalPeriod: 29.457,
        rotationPeriod: 0.444, // 10.7 hours
        mass: 5.6834e26,
        density: 0.687, // Less dense than water!
        temperature: { min: -178, max: -139 },
        color: 0xF4CA16,
        atmosphere: { 
          pressure: 1000,
          composition: "96% H₂, 3% He, 1% CH₄+NH₃+trace" 
        },
        moons: [
          {
            name: "Titan",
            radius: 2574,
            distance: 0.00817,
            mass: 1.345e23,
            orbitalPeriod: 15.95,
            color: 0xFFAA88,
            hasAtmosphere: true,
            hasLakes: true // Methane lakes
          },
          {
            name: "Enceladus",
            radius: 252.1,
            distance: 0.00159,
            mass: 1.08e20,
            orbitalPeriod: 1.37,
            color: 0xFFFFFF,
            hasGeysers: true
          }
        ],
        detail: 4,
        hasRings: true,
        ringSystem: {
          innerRadius: 74500, // km from center
          outerRadius: 282000,
          thickness: 10, // meters
          composition: "99% water ice"
        },
        discovery: "Ancient",
        physicalCharacteristics: {
          magneticField: 578,
          surfaceGravity: 10.44,
          escapeVelocity: 35.5,
          albedo: 0.342
        }
      },
      {
        name: "Uranus",
        radius: 25362,
        distance: 19.165,
        orbitalPeriod: 84.01,
        rotationPeriod: -0.718, // Retrograde, 17.2 hours
        mass: 8.6810e25,
        density: 1.27,
        temperature: { min: -224, max: -197 },
        color: 0x4FD0E7,
        atmosphere: { 
          pressure: 1000,
          composition: "83% H₂, 15% He, 2% CH₄" 
        },
        moons: [
          {
            name: "Miranda",
            radius: 235.8,
            distance: 0.000867,
            mass: 6.59e19,
            orbitalPeriod: 1.41,
            color: 0xCCCCCC
          },
          {
            name: "Ariel",
            radius: 578.9,
            distance: 0.00128,
            mass: 1.35e21,
            orbitalPeriod: 2.52,
            color: 0xDDDDDD
          }
        ],
        detail: 3,
        hasRings: true,
        discovery: "1781 - William Herschel",
        physicalCharacteristics: {
          magneticField: 50,
          surfaceGravity: 8.69,
          escapeVelocity: 21.3,
          albedo: 0.300
        },
        uniqueFeatures: {
          axialTilt: 97.77, // Nearly sideways
          magneticFieldTilt: 58.6 // Tilted from rotation axis
        }
      },
      {
        name: "Neptune",
        radius: 24622,
        distance: 30.178,
        orbitalPeriod: 164.8,
        rotationPeriod: 0.671, // 16.1 hours
        mass: 1.02413e26,
        density: 1.638,
        temperature: { min: -218, max: -200 },
        color: 0x4166F5,
        atmosphere: { 
          pressure: 1000,
          composition: "80% H₂, 19% He, 1% CH₄" 
        },
        moons: [
          {
            name: "Triton",
            radius: 1353.4,
            distance: 0.00236,
            mass: 2.14e22,
            orbitalPeriod: -5.88, // Retrograde orbit
            color: 0xFFB6C1,
            hasGeysers: true
          }
        ],
        detail: 3,
        hasRings: true,
        discovery: "1846 - Mathematical prediction",
        physicalCharacteristics: {
          magneticField: 27,
          surfaceGravity: 11.15,
          escapeVelocity: 23.5,
          albedo: 0.290
        },
        storms: {
          greatDarkSpot: true,
          windSpeed: 2100 // km/h - fastest in solar system
        }
      }
    ];

    realSolarSystemData.forEach((data) => {
      // Scale radius for visibility (real scale would be invisible)
      const visualRadius = Math.log(data.radius + 1) * 2; // Logarithmic scaling for visibility
      const visualDistance = data.distance * 100; // Scale distance for AU to scene units
      
      const geometry = new THREE.IcosahedronGeometry(visualRadius, data.detail);
      
      // Enhanced material with real planetary characteristics
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          planetData: { value: data },
          hasAtmosphere: { value: data.atmosphere.pressure > 0 ? 1.0 : 0.0 },
          temperature: { value: (data.temperature.min + data.temperature.max) / 2 },
          hasLife: { value: data.biosphere?.hasLife ? 1.0 : 0.0 },
        },
        vertexShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          uniform float time;
          
          void main() {
            vPosition = position;
            vNormal = normal;
            
            // Add slight planetary rotation based on real rotation period
            vec3 pos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          uniform float time;
          uniform float hasAtmosphere;
          uniform float temperature;
          uniform float hasLife;
          
          void main() {
            vec3 baseColor = vec3(${((data.color >> 16) & 0xFF) / 255.0}, ${((data.color >> 8) & 0xFF) / 255.0}, ${(data.color & 0xFF) / 255.0});
            
            // Add atmospheric glow
            float atmosphereGlow = 0.0;
            if (hasAtmosphere > 0.5) {
              float rim = 1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));
              atmosphereGlow = rim * 0.3;
            }
            
            // Add temperature-based color variation
            float tempFactor = (temperature + 273.0) / 500.0; // Normalize temperature
            vec3 tempColor = mix(vec3(0.3, 0.5, 1.0), vec3(1.0, 0.3, 0.1), tempFactor);
            
            // Add life indicator (subtle green tint for Earth)
            if (hasLife > 0.5) {
              baseColor = mix(baseColor, vec3(0.2, 0.8, 0.3), 0.2);
            }
            
            vec3 finalColor = mix(baseColor, tempColor, 0.1) + vec3(atmosphereGlow);
            
            gl_FragColor = vec4(finalColor, 1.0);
          }
        `,
      });
      
      const planet = new THREE.Mesh(geometry, material);
      
      // Store ALL NASA data in userData
      planet.userData = {
        ...data,
        angle: Math.random() * Math.PI * 2,
        visualRadius: visualRadius,
        visualDistance: visualDistance,
        realData: data // Keep original data for information display
      };
      
      planets.push(planet);
      scene.add(planet);

      // Create moons from real data
      data.moons.forEach((moonData, moonIndex) => {
        const moonVisualRadius = Math.log(moonData.radius + 1) * 1.5;
        const moonVisualDistance = moonData.distance * 100 + visualRadius + 5; // Offset from planet
        
        const moonGeometry = new THREE.SphereGeometry(moonVisualRadius, 16, 16);
        const moonMaterial = new THREE.MeshPhongMaterial({
          color: moonData.color,
        });
        
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.userData = {
          ...moonData,
          parentPlanet: data.name,
          angle: Math.random() * Math.PI * 2,
          distance: moonVisualDistance,
          isMoon: true
        };
        
        planet.add(moon); // Attach moon to planet
      });

      // Real orbital path
      const curve = new THREE.EllipseCurve(
        0,
        0,
        visualDistance,
        visualDistance,
        0,
        2 * Math.PI
      );
      const points = curve.getPoints(128); // More points for smoother orbits
      const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const orbitMaterial = new THREE.LineBasicMaterial({
        color: 0x444444,
        opacity: 0.2,
        transparent: true,
      });
      const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
      orbit.rotation.x = Math.PI / 2;
      scene.add(orbit);
    });

    // ========== ASTEROID BELT ==========
    const asteroidGeometry = new THREE.BufferGeometry();
    const asteroidCount = 500;
    const asteroidPositions = new Float32Array(asteroidCount * 3);

    for (let i = 0; i < asteroidCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 200 + Math.random() * 50;
      const i3 = i * 3;
      asteroidPositions[i3] = Math.cos(angle) * radius;
      asteroidPositions[i3 + 1] = (Math.random() - 0.5) * 10;
      asteroidPositions[i3 + 2] = Math.sin(angle) * radius;
    }

    asteroidGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(asteroidPositions, 3)
    );
    const asteroidMaterial = new THREE.PointsMaterial({
      color: 0x666666,
      size: 2,
    });
    const asteroids = new THREE.Points(asteroidGeometry, asteroidMaterial);
    scene.add(asteroids);

    // ========== COMET ==========
    const cometGeometry = new THREE.SphereGeometry(2, 16, 16);
    const cometMaterial = new THREE.MeshBasicMaterial({
      color: 0x88aaff,
      emissive: 0x4488ff,
      emissiveIntensity: 1,
    });
    const comet = new THREE.Mesh(cometGeometry, cometMaterial);
    comet.userData = {
      angle: 0,
      radius: 350,
      speed: 2,
      verticalSpeed: 0.5,
    };
    scene.add(comet);

    // Comet tail
    const cometTailGeometry = new THREE.ConeGeometry(1, 20, 8);
    const cometTailMaterial = new THREE.MeshBasicMaterial({
      color: 0x4488ff,
      transparent: true,
      opacity: 0.3,
      blending: THREE.AdditiveBlending,
    });
    const cometTail = new THREE.Mesh(cometTailGeometry, cometTailMaterial);
    comet.add(cometTail);
    cometTail.rotation.z = Math.PI / 2;

    // ========== NEBULAE ==========
    const createNebula = (position, color1, color2, size) => {
      const particleCount = 5000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = Math.random() * size * (0.5 + 0.5 * Math.random());

        positions[i3] =
          r * Math.sin(phi) * Math.cos(theta) +
          (Math.random() - 0.5) * size * 0.5;
        positions[i3 + 1] =
          r * Math.sin(phi) * Math.sin(theta) +
          (Math.random() - 0.5) * size * 0.3;
        positions[i3 + 2] =
          r * Math.cos(phi) + (Math.random() - 0.5) * size * 0.5;

        const mixFactor = Math.random();
        const color = new THREE.Color().lerpColors(color1, color2, mixFactor);
        colors[i3] = color.r;
        colors[i3 + 1] = color.g;
        colors[i3 + 2] = color.b;

        sizes[i] = Math.random() * 5 + 2;
      }

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          uniform float time;
          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float pulse = sin(time * 0.5 + position.x * 0.01) * 0.2 + 1.0;
            gl_PointSize = size * pulse * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            float intensity = 1.0 - (r * 2.0);
            intensity = pow(intensity, 2.0);
            gl_FragColor = vec4(vColor * intensity, intensity * 0.8);
          }
        `,
        blending: THREE.AdditiveBlending,
        transparent: true,
        vertexColors: true,
        depthWrite: false,
      });

      const nebula = new THREE.Points(geometry, material);
      nebula.position.copy(position);
      return nebula;
    };

    // ========== JWST-INSPIRED NEBULAE ==========
    const createJWSTNebula = (position, config) => {
      const group = new THREE.Group();

      // Layer 1: Dense core with volumetric clouds
      const coreGeometry = new THREE.BufferGeometry();
      const coreCount = 20000;
      const corePositions = new Float32Array(coreCount * 3);
      const coreColors = new Float32Array(coreCount * 3);
      const coreSizes = new Float32Array(coreCount);

      for (let i = 0; i < coreCount; i++) {
        const i3 = i * 3;

        // Create complex 3D structures like pillars
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = Math.random() * config.size;

        // Add pillar-like structures
        const pillarNoise =
          Math.sin(theta * 3) * Math.cos(phi * 2) * config.size * 0.3;
        const turbulence = (Math.random() - 0.5) * config.size * 0.2;

        corePositions[i3] =
          r * Math.sin(phi) * Math.cos(theta) + pillarNoise + turbulence;
        corePositions[i3 + 1] =
          r * Math.sin(phi) * Math.sin(theta) + turbulence * 0.5;
        corePositions[i3 + 2] =
          r * Math.cos(phi) + pillarNoise * 0.7 + turbulence;

        // Multi-color gradients
        const zone = Math.random();
        let color;
        if (zone < 0.3) {
          color = new THREE.Color().lerpColors(
            config.colors[0],
            config.colors[1],
            Math.random()
          );
        } else if (zone < 0.6) {
          color = new THREE.Color().lerpColors(
            config.colors[1],
            config.colors[2],
            Math.random()
          );
        } else {
          color = new THREE.Color().lerpColors(
            config.colors[2],
            config.colors[3],
            Math.random()
          );
        }

        const brightness = 0.5 + Math.random() * 0.5;
        coreColors[i3] = color.r * brightness;
        coreColors[i3 + 1] = color.g * brightness;
        coreColors[i3 + 2] = color.b * brightness;

        coreSizes[i] = Math.random() * 8 + 2;
      }

      coreGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(corePositions, 3)
      );
      coreGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(coreColors, 3)
      );
      coreGeometry.setAttribute(
        "size",
        new THREE.BufferAttribute(coreSizes, 1)
      );

      const coreMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          scale: { value: 1.0 },
        },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          uniform float time;
          uniform float scale;
          
          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            
            // Pulsing and swirling motion
            float pulse = sin(time * 0.5 + position.x * 0.01 + position.y * 0.01) * 0.2 + 1.0;
            float swirl = sin(time * 0.3 + length(position.xy) * 0.005) * 0.1;
            
            gl_PointSize = size * pulse * scale * (500.0 / -mvPosition.z);
            vec3 pos = position;
            pos.xy += vec2(cos(swirl), sin(swirl)) * 5.0;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          
          void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            
            // Soft, glowing particles
            float intensity = 1.0 - (r * 2.0);
            intensity = pow(intensity, 1.5);
            
            // Add subtle color variations
            vec3 color = vColor;
            color += vec3(0.1, 0.05, 0.15) * (1.0 - intensity);
            
            gl_FragColor = vec4(color * intensity, intensity * 0.7);
          }
        `,
        blending: THREE.AdditiveBlending,
        transparent: true,
        vertexColors: true,
        depthWrite: false,
      });

      const core = new THREE.Points(coreGeometry, coreMaterial);
      group.add(core);

      // Layer 2: Wispy outer regions
      const wispsGeometry = new THREE.BufferGeometry();
      const wispsCount = 15000;
      const wispsPositions = new Float32Array(wispsCount * 3);
      const wispsColors = new Float32Array(wispsCount * 3);
      const wispsSizes = new Float32Array(wispsCount);

      for (let i = 0; i < wispsCount; i++) {
        const i3 = i * 3;

        // Create flowing, wispy structures
        const angle = Math.random() * Math.PI * 2;
        const radius = config.size * (0.8 + Math.random() * 0.6);
        const height = (Math.random() - 0.5) * config.size;

        // Add flowing motion
        const flow = Math.sin(angle * 4) * config.size * 0.2;

        wispsPositions[i3] = Math.cos(angle) * radius + flow;
        wispsPositions[i3 + 1] =
          height + Math.sin(radius * 0.01) * config.size * 0.1;
        wispsPositions[i3 + 2] = Math.sin(angle) * radius + flow;

        // Ethereal colors for wisps
        const wispColor =
          config.colors[Math.floor(Math.random() * config.colors.length)];
        const fade = 1.0 - (radius - config.size * 0.8) / (config.size * 0.6);

        wispsColors[i3] = wispColor.r * fade * 0.6;
        wispsColors[i3 + 1] = wispColor.g * fade * 0.6;
        wispsColors[i3 + 2] = wispColor.b * fade * 0.8;

        wispsSizes[i] = Math.random() * 15 + 5;
      }

      wispsGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(wispsPositions, 3)
      );
      wispsGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(wispsColors, 3)
      );
      wispsGeometry.setAttribute(
        "size",
        new THREE.BufferAttribute(wispsSizes, 1)
      );

      const wispsMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          uniform float time;
          
          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            
            // Gentle floating motion
            vec3 pos = position;
            pos.y += sin(time * 0.2 + position.x * 0.01) * 2.0;
            pos.x += cos(time * 0.15 + position.z * 0.01) * 1.5;
            
            gl_PointSize = size * (800.0 / -mvPosition.z);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          
          void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if (r > 0.5) discard;
            
            float intensity = 1.0 - (r * 2.0);
            intensity = pow(intensity, 2.5);
            
            gl_FragColor = vec4(vColor * intensity, intensity * 0.3);
          }
        `,
        blending: THREE.AdditiveBlending,
        transparent: true,
        vertexColors: true,
        depthWrite: false,
      });

      const wisps = new THREE.Points(wispsGeometry, wispsMaterial);
      group.add(wisps);

      // Layer 3: Bright stars embedded in nebula
      const starsGeometry = new THREE.BufferGeometry();
      const starsCount = 200;
      const starsPositions = new Float32Array(starsCount * 3);
      const starsColors = new Float32Array(starsCount * 3);
      const starsSizes = new Float32Array(starsCount);

      for (let i = 0; i < starsCount; i++) {
        const i3 = i * 3;

        // Cluster stars in certain regions
        const cluster = Math.random() < 0.3;
        const spread = cluster ? config.size * 0.2 : config.size * 0.8;

        starsPositions[i3] = (Math.random() - 0.5) * spread;
        starsPositions[i3 + 1] = (Math.random() - 0.5) * spread;
        starsPositions[i3 + 2] = (Math.random() - 0.5) * spread;

        // Hot blue stars and cooler red stars
        const hot = Math.random() < 0.6;
        if (hot) {
          starsColors[i3] = 0.8;
          starsColors[i3 + 1] = 0.9;
          starsColors[i3 + 2] = 1.0;
        } else {
          starsColors[i3] = 1.0;
          starsColors[i3 + 1] = 0.7;
          starsColors[i3 + 2] = 0.4;
        }

        starsSizes[i] = cluster
          ? Math.random() * 30 + 20
          : Math.random() * 20 + 10;
      }

      starsGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(starsPositions, 3)
      );
      starsGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(starsColors, 3)
      );
      starsGeometry.setAttribute(
        "size",
        new THREE.BufferAttribute(starsSizes, 1)
      );

      const starsMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
        },
        vertexShader: `
          attribute float size;
          varying vec3 vColor;
          uniform float time;
          
          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            
            // Twinkling effect
            float twinkle = sin(time * 3.0 + position.x * position.y) * 0.2 + 1.0;
            
            gl_PointSize = size * twinkle * (1000.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          
          void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            
            // Star spike effect
            float spike = 1.0 - abs(gl_PointCoord.x - 0.5) * 2.0;
            spike *= 1.0 - abs(gl_PointCoord.y - 0.5) * 2.0;
            spike = pow(spike, 3.0);
            
            // Circular core
            float core = 1.0 - smoothstep(0.0, 0.5, r);
            core = pow(core, 2.0);
            
            float intensity = max(core, spike * 0.5);
            
            vec3 color = vColor * (1.0 + spike);
            
            gl_FragColor = vec4(color * intensity, intensity);
          }
        `,
        blending: THREE.AdditiveBlending,
        transparent: true,
        vertexColors: true,
        depthWrite: false,
      });

      const stars = new THREE.Points(starsGeometry, starsMaterial);
      group.add(stars);

      // Store materials for animation
      group.userData = {
        coreMaterial,
        wispsMaterial,
        starsMaterial,
        config,
      };

      group.position.copy(position);
      return group;
    };

    // Create JWST-style nebulae
    const jwstNebulae = [
      // Pillars of Creation style
      createJWSTNebula(new THREE.Vector3(500, 100, -300), {
        size: 250,
        colors: [
          new THREE.Color(0x8b4513), // Saddle Brown
          new THREE.Color(0xcd853f), // Peru
          new THREE.Color(0xffd700), // Gold
          new THREE.Color(0x4682b4), // Steel Blue
        ],
      }),
      // Carina Nebula style
      createJWSTNebula(new THREE.Vector3(-600, -100, 400), {
        size: 350,
        colors: [
          new THREE.Color(0xff1493), // Deep Pink
          new THREE.Color(0xff6347), // Tomato
          new THREE.Color(0xffd700), // Gold
          new THREE.Color(0x00ced1), // Dark Turquoise
        ],
      }),
      // Supernova remnant style
      createJWSTNebula(new THREE.Vector3(200, -200, 600), {
        size: 300,
        colors: [
          new THREE.Color(0x00bfff), // Deep Sky Blue
          new THREE.Color(0x32cd32), // Lime Green
          new THREE.Color(0xff69b4), // Hot Pink
          new THREE.Color(0x9370db), // Medium Purple
        ],
      }),
    ];

    jwstNebulae.forEach((nebula) => scene.add(nebula));

    // ========== LIGHTNING EFFECTS ==========
    const lightningBolts = [];
    const createLightning = () => {
      const points = [];
      const startPoint = new THREE.Vector3(
        (Math.random() - 0.5) * 1000,
        (Math.random() - 0.5) * 1000,
        (Math.random() - 0.5) * 1000
      );
      const endPoint = new THREE.Vector3(
        startPoint.x + (Math.random() - 0.5) * 200,
        startPoint.y + (Math.random() - 0.5) * 200,
        startPoint.z + (Math.random() - 0.5) * 200
      );

      points.push(startPoint);

      const segments = 8;
      for (let i = 1; i < segments; i++) {
        const t = i / segments;
        const point = new THREE.Vector3().lerpVectors(startPoint, endPoint, t);
        point.x += (Math.random() - 0.5) * 20;
        point.y += (Math.random() - 0.5) * 20;
        point.z += (Math.random() - 0.5) * 20;
        points.push(point);
      }
      points.push(endPoint);

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: new THREE.Color(0x88ccff),
        linewidth: 2,
        transparent: true,
        opacity: 0.8,
      });

      const lightning = new THREE.Line(geometry, material);
      lightning.userData.lifetime = 0;

      // Add glow effect to lightning
      const glowGeometry = geometry.clone();
      const glowMaterial = new THREE.LineBasicMaterial({
        color: new THREE.Color(0xffffff),
        linewidth: 3,
        transparent: true,
        opacity: 0.3,
      });
      const glowLine = new THREE.Line(glowGeometry, glowMaterial);
      lightning.add(glowLine);

      return lightning;
    };

    // ========== REAL HIPPARCOS/GAIA STAR CATALOG ==========
    // Real stellar data from Hipparcos and Gaia astronomical catalogs
    const realNearbyStars = [
      {
        name: "Alpha Centauri A",
        distance: 4.37, // light-years
        spectralClass: "G2V",
        magnitude: -0.01,
        temperature: 5790, // Kelvin
        mass: 1.1, // Solar masses
        radius: 1.2, // Solar radii
        position: { ra: 219.9, dec: -60.8 }, // Right ascension, declination
        properMotion: { ra: -3678.19, dec: 481.84 }, // mas/year
        color: 0xFFFF88,
        isMultipleSystem: true,
        companions: ["Alpha Centauri B", "Proxima Centauri"]
      },
      {
        name: "Alpha Centauri B",
        distance: 4.37,
        spectralClass: "K1V",
        magnitude: 1.35,
        temperature: 5260,
        mass: 0.91,
        radius: 0.86,
        position: { ra: 219.9, dec: -60.8 },
        properMotion: { ra: -3678.19, dec: 481.84 },
        color: 0xFFAA44,
        isMultipleSystem: true
      },
      {
        name: "Proxima Centauri",
        distance: 4.24,
        spectralClass: "M5.5Ve",
        magnitude: 11.13,
        temperature: 3042,
        mass: 0.12,
        radius: 0.15,
        position: { ra: 217.4, dec: -62.7 },
        properMotion: { ra: -3775.40, dec: 765.54 },
        color: 0xFF4444,
        isFlarestar: true,
        hasExoplanets: true
      },
      {
        name: "Barnard's Star",
        distance: 5.96,
        spectralClass: "M4.0Ve",
        magnitude: 9.53,
        temperature: 3134,
        mass: 0.14,
        radius: 0.20,
        position: { ra: 269.4, dec: 4.7 },
        properMotion: { ra: -798.58, dec: 10328.12 }, // Highest proper motion
        color: 0xFF6666,
        isFlarestar: true
      },
      {
        name: "Wolf 359",
        distance: 7.86,
        spectralClass: "M6.0V",
        magnitude: 13.54,
        temperature: 2800,
        mass: 0.09,
        radius: 0.16,
        position: { ra: 164.1, dec: 7.0 },
        properMotion: { ra: -3842.11, dec: -2725.56 },
        color: 0xFF2222,
        isFlarestar: true
      },
      {
        name: "Sirius A",
        distance: 8.66,
        spectralClass: "A1V",
        magnitude: -1.47, // Brightest star in night sky
        temperature: 9940,
        mass: 2.063,
        radius: 1.71,
        position: { ra: 101.3, dec: -16.7 },
        properMotion: { ra: -546.01, dec: -1223.08 },
        color: 0xAABBFF,
        isMultipleSystem: true,
        companions: ["Sirius B"]
      },
      {
        name: "Sirius B",
        distance: 8.66,
        spectralClass: "DA2", // White dwarf
        magnitude: 8.44,
        temperature: 25200,
        mass: 0.978,
        radius: 0.0084, // Very small white dwarf
        position: { ra: 101.3, dec: -16.7 },
        properMotion: { ra: -546.01, dec: -1223.08 },
        color: 0xFFFFFF,
        isWhiteDwarf: true
      },
      {
        name: "Epsilon Eridani",
        distance: 10.5,
        spectralClass: "K2V",
        magnitude: 3.73,
        temperature: 5084,
        mass: 0.82,
        radius: 0.735,
        position: { ra: 53.2, dec: -9.5 },
        properMotion: { ra: -975.17, dec: 19.49 },
        color: 0xFFAA66,
        hasExoplanets: true,
        hasDebrisDisk: true
      },
      {
        name: "Procyon A",
        distance: 11.5,
        spectralClass: "F5IV-V",
        magnitude: 0.34,
        temperature: 6530,
        mass: 1.499,
        radius: 2.048,
        position: { ra: 114.8, dec: 5.2 },
        properMotion: { ra: -714.59, dec: -1036.80 },
        color: 0xFFFF99,
        isMultipleSystem: true,
        companions: ["Procyon B"]
      },
      {
        name: "Procyon B",
        distance: 11.5,
        spectralClass: "DQZ", // White dwarf
        magnitude: 10.7,
        temperature: 7740,
        mass: 0.602,
        radius: 0.01234,
        position: { ra: 114.8, dec: 5.2 },
        properMotion: { ra: -714.59, dec: -1036.80 },
        color: 0xEEEEFF,
        isWhiteDwarf: true
      },
      {
        name: "61 Cygni A",
        distance: 11.4,
        spectralClass: "K5.0V",
        magnitude: 5.21,
        temperature: 4374,
        mass: 0.70,
        radius: 0.665,
        position: { ra: 310.4, dec: 38.5 },
        properMotion: { ra: 4156.93, dec: 3259.39 },
        color: 0xFF8844,
        isMultipleSystem: true,
        historicalSignificance: "First star with measured parallax"
      },
      {
        name: "Vega",
        distance: 25.0,
        spectralClass: "A0Va",
        magnitude: 0.03,
        temperature: 9602,
        mass: 2.135,
        radius: 2.362,
        position: { ra: 279.2, dec: 38.8 },
        properMotion: { ra: 200.94, dec: 286.23 },
        color: 0x9999FF,
        hasDebrisDisk: true,
        historicalSignificance: "Former pole star, photometric standard"
      },
      {
        name: "Altair",
        distance: 16.7,
        spectralClass: "A7V",
        magnitude: 0.77,
        temperature: 7550,
        mass: 1.79,
        radius: 1.63,
        position: { ra: 297.7, dec: 8.9 },
        properMotion: { ra: 536.23, dec: 385.29 },
        color: 0xAABBFF,
        rotationVelocity: 286, // km/s - very fast rotation
        isOblateDueToRotation: true
      },
      {
        name: "Alpha Centauri C", // Proxima duplicate check
        skipDuplicate: true
      },
      {
        name: "Arcturus",
        distance: 36.7,
        spectralClass: "K0III",
        magnitude: -0.05,
        temperature: 4286,
        mass: 1.08,
        radius: 25.4, // Giant star
        position: { ra: 213.9, dec: 19.2 },
        properMotion: { ra: -1093.45, dec: -1999.40 },
        color: 0xFF6600,
        isRedGiant: true,
        metalPoor: true
      },
      {
        name: "Capella Aa",
        distance: 42.9,
        spectralClass: "G6III",
        magnitude: 0.08,
        temperature: 4970,
        mass: 2.5687,
        radius: 11.98,
        position: { ra: 79.2, dec: 46.0 },
        properMotion: { ra: 75.52, dec: -427.13 },
        color: 0xFFDD66,
        isMultipleSystem: true,
        isGiant: true
      },
      {
        name: "Rigel",
        distance: 860,
        spectralClass: "B8Ia",
        magnitude: 0.13,
        temperature: 12100,
        mass: 21,
        radius: 78.9, // Supergiant
        position: { ra: 78.6, dec: -8.2 },
        properMotion: { ra: 1.31, dec: 0.50 },
        color: 0x6666FF,
        isBlueSuperGiant: true,
        willBecomeSupernova: true
      },
      {
        name: "Betelgeuse",
        distance: 548,
        spectralClass: "M1-2Ia-ab",
        magnitude: 0.50, // Variable
        temperature: 3590,
        mass: 16.5,
        radius: 887, // Enormous red supergiant
        position: { ra: 88.8, dec: 7.4 },
        properMotion: { ra: 27.33, dec: 10.86 },
        color: 0xFF4400,
        isRedSuperGiant: true,
        isVariable: true,
        willBecomeSupernova: true
      },
      {
        name: "Spica",
        distance: 250,
        spectralClass: "B1III-IV",
        magnitude: 1.04,
        temperature: 22400,
        mass: 11.43,
        radius: 7.47,
        position: { ra: 201.3, dec: -11.2 },
        properMotion: { ra: -42.50, dec: -31.73 },
        color: 0x4444FF,
        isMultipleSystem: true,
        isBeta_CepheiVariable: true
      },
      {
        name: "Antares",
        distance: 550,
        spectralClass: "M1.5Iab-Ib",
        magnitude: 1.09, // Variable
        temperature: 3660,
        mass: 12,
        radius: 700, // Red supergiant
        position: { ra: 247.4, dec: -26.4 },
        properMotion: { ra: -12.11, dec: -23.30 },
        color: 0xFF2200,
        isRedSuperGiant: true,
        isVariable: true,
        hasCompanion: true
      },
      {
        name: "Polaris",
        distance: 433,
        spectralClass: "F7Ib",
        magnitude: 1.98,
        temperature: 6015,
        mass: 5.4,
        radius: 37.5,
        position: { ra: 37.9, dec: 89.3 }, // Very close to north celestial pole
        properMotion: { ra: 44.22, dec: -11.74 },
        color: 0xFFFF99,
        isCurrentPoleStar: true,
        isCepheidVariable: true,
        isMultipleSystem: true
      }
    ];

    // Create enhanced star visualization with real astronomical data
    const starsGeometry = new THREE.BufferGeometry();
    const totalStars = realNearbyStars.length + 20000; // Real stars + procedural background
    const starPositions = new Float32Array(totalStars * 3);
    const starColors = new Float32Array(totalStars * 3);
    const starSizes = new Float32Array(totalStars);
    const starData = [];

    let starIndex = 0;

    // Add real catalog stars first
    realNearbyStars.forEach((star) => {
      if (star.skipDuplicate) return;
      
      const i3 = starIndex * 3;
      
      // Convert astronomical coordinates to 3D position
      const ra = star.position.ra * (Math.PI / 180); // Right ascension to radians
      const dec = star.position.dec * (Math.PI / 180); // Declination to radians
      const distance = star.distance * 100; // Scale for scene units
      
      // Convert spherical coordinates (RA/Dec) to Cartesian
      starPositions[i3] = distance * Math.cos(dec) * Math.cos(ra);
      starPositions[i3 + 1] = distance * Math.sin(dec);
      starPositions[i3 + 2] = distance * Math.cos(dec) * Math.sin(ra);
      
      // Accurate stellar colors based on spectral class and temperature
      let color = new THREE.Color();
      if (star.temperature > 30000) {
        color.setHex(0x9999FF); // O-type: Blue
      } else if (star.temperature > 10000) {
        color.setHex(0xBBBBFF); // B-type: Blue-white
      } else if (star.temperature > 7500) {
        color.setHex(0xFFFFFF); // A-type: White
      } else if (star.temperature > 6000) {
        color.setHex(0xFFFF99); // F-type: Yellow-white
      } else if (star.temperature > 5200) {
        color.setHex(0xFFDD66); // G-type: Yellow (like Sun)
      } else if (star.temperature > 3700) {
        color.setHex(0xFFAA44); // K-type: Orange
      } else {
        color.setHex(0xFF6644); // M-type: Red
      }
      
      starColors[i3] = color.r;
      starColors[i3 + 1] = color.g;
      starColors[i3 + 2] = color.b;
      
      // Size based on magnitude and stellar type
      let visualSize = 5 - star.magnitude; // Brighter = larger
      if (star.isRedGiant || star.isRedSuperGiant) {
        visualSize *= 2; // Giants appear larger
      }
      if (star.isWhiteDwarf) {
        visualSize *= 0.5; // White dwarfs appear smaller
      }
      starSizes[starIndex] = Math.max(1, visualSize);
      
      // Store comprehensive stellar data
      starData.push({
        ...star,
        index: starIndex,
        isRealStar: true,
        position3d: {
          x: starPositions[i3],
          y: starPositions[i3 + 1],
          z: starPositions[i3 + 2]
        }
      });
      
      starIndex++;
    });

    // Add procedural background stars
    for (let i = starIndex; i < totalStars; i++) {
      const i3 = i * 3;
      const radius = 500 + Math.random() * 10000;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);

      starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
      starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      starPositions[i3 + 2] = radius * Math.cos(phi);

      // Realistic stellar population colors
      const starType = Math.random();
      if (starType > 0.95) {
        // O/B type stars (5% - hot blue stars)
        starColors[i3] = 0.7;
        starColors[i3 + 1] = 0.8;
        starColors[i3 + 2] = 1.0;
        starSizes[i] = Math.random() * 4 + 3;
      } else if (starType > 0.85) {
        // A type stars (10% - white stars)
        starColors[i3] = 1.0;
        starColors[i3 + 1] = 1.0;
        starColors[i3 + 2] = 1.0;
        starSizes[i] = Math.random() * 3 + 2;
      } else if (starType > 0.70) {
        // F/G type stars (15% - yellow stars like Sun)
        starColors[i3] = 1.0;
        starColors[i3 + 1] = 0.9;
        starColors[i3 + 2] = 0.7;
        starSizes[i] = Math.random() * 2 + 1.5;
      } else if (starType > 0.40) {
        // K type stars (30% - orange stars)
        starColors[i3] = 1.0;
        starColors[i3 + 1] = 0.7;
        starColors[i3 + 2] = 0.5;
        starSizes[i] = Math.random() * 1.5 + 1;
      } else {
        // M type stars (40% - red dwarfs, most common)
        starColors[i3] = 1.0;
        starColors[i3 + 1] = 0.6;
        starColors[i3 + 2] = 0.4;
        starSizes[i] = Math.random() * 1 + 0.5;
      }
    }

    starsGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(starPositions, 3)
    );
    starsGeometry.setAttribute(
      "color",
      new THREE.BufferAttribute(starColors, 3)
    );
    starsGeometry.setAttribute("size", new THREE.BufferAttribute(starSizes, 1));

    const starsMaterial = new THREE.ShaderMaterial({
      uniforms: {
        scale: { value: 1.0 },
      },
      vertexShader: `
        attribute float size;
        varying vec3 vColor;
        uniform float scale;
        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * scale * (300.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        void main() {
          float r = distance(gl_PointCoord, vec2(0.5));
          if (r > 0.5) discard;
          float intensity = 1.0 - (r * 2.0);
          intensity = pow(intensity, 3.0);
          gl_FragColor = vec4(vColor * intensity, intensity);
        }
      `,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
    });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // Note: Detailed Milky Way galaxy already created above

    // ========== DISTANT GALAXIES ==========
    const galaxies = [];

    // Random background galaxies
    for (let i = 0; i < 100; i++) {
      const pos = new THREE.Vector3(
        (Math.random() - 0.5) * 1000000,
        (Math.random() - 0.5) * 1000000,
        (Math.random() - 0.5) * 1000000
      );

      const galaxyGeometry = new THREE.BufferGeometry();
      const galaxyPositions = new Float32Array(1000 * 3);
      const galaxyColors = new Float32Array(1000 * 3);

      for (let j = 0; j < 1000; j++) {
        const armAngle = (j % 3) * ((Math.PI * 2) / 3);
        const radius = Math.random() * 1000;
        const spiralAngle = armAngle + radius * 0.01;

        const j3 = j * 3;
        galaxyPositions[j3] = Math.cos(spiralAngle) * radius;
        galaxyPositions[j3 + 1] = (Math.random() - 0.5) * radius * 0.1;
        galaxyPositions[j3 + 2] = Math.sin(spiralAngle) * radius;

        const brightness = 1 - (radius / 1000) * 0.5;
        galaxyColors[j3] = brightness * (0.5 + Math.random() * 0.5);
        galaxyColors[j3 + 1] = brightness * (0.5 + Math.random() * 0.5);
        galaxyColors[j3 + 2] = brightness * (0.5 + Math.random() * 0.5);
      }

      galaxyGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(galaxyPositions, 3)
      );
      galaxyGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(galaxyColors, 3)
      );

      const galaxyMaterial = new THREE.PointsMaterial({
        size: 5,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: false,
      });

      const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
      galaxy.position.copy(pos);
      galaxy.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );
      galaxies.push(galaxy);
      scene.add(galaxy);
    }

    // ========== REAL NASA EXOPLANET ARCHIVE DATA ==========
    // Comprehensive exoplanet database from NASA's Exoplanet Archive
    const realExoplanets = [
      {
        name: "Proxima Centauri b",
        hostStar: "Proxima Centauri",
        distance: 4.24, // light-years from Earth
        orbitalPeriod: 11.186, // Earth days
        radius: 1.17, // Earth radii
        mass: 1.27, // Earth masses
        equilibriumTemp: 234, // Kelvin
        discoveryYear: 2016,
        discoveryMethod: "Radial Velocity",
        inHabitableZone: true,
        color: 0xff6b6b,
        stellarMagnitude: 11.13,
        eccentricity: 0.109,
        semiMajorAxis: 0.0485, // AU
        planetType: "Terrestrial"
      },
      {
        name: "TRAPPIST-1 b",
        hostStar: "TRAPPIST-1",
        distance: 39.5,
        orbitalPeriod: 1.51,
        radius: 1.086,
        mass: 1.374,
        equilibriumTemp: 400,
        discoveryYear: 2016,
        discoveryMethod: "Transit",
        inHabitableZone: false,
        color: 0xff4444,
        stellarMagnitude: 18.8,
        eccentricity: 0.0,
        semiMajorAxis: 0.01154,
        planetType: "Terrestrial"
      },
      {
        name: "TRAPPIST-1 c",
        hostStar: "TRAPPIST-1",
        distance: 39.5,
        orbitalPeriod: 2.42,
        radius: 1.056,
        mass: 1.308,
        equilibriumTemp: 342,
        discoveryYear: 2016,
        discoveryMethod: "Transit",
        inHabitableZone: false,
        color: 0xff6644,
        stellarMagnitude: 18.8,
        eccentricity: 0.0,
        semiMajorAxis: 0.01580,
        planetType: "Terrestrial"
      },
      {
        name: "TRAPPIST-1 d",
        hostStar: "TRAPPIST-1",
        distance: 39.5,
        orbitalPeriod: 4.05,
        radius: 0.772,
        mass: 0.388,
        equilibriumTemp: 288,
        discoveryYear: 2016,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0xff9f40,
        stellarMagnitude: 18.8,
        eccentricity: 0.0,
        semiMajorAxis: 0.02227,
        planetType: "Terrestrial"
      },
      {
        name: "TRAPPIST-1 e",
        hostStar: "TRAPPIST-1",
        distance: 39.5,
        orbitalPeriod: 6.10,
        radius: 0.918,
        mass: 0.692,
        equilibriumTemp: 251,
        discoveryYear: 2016,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0xffaa66,
        stellarMagnitude: 18.8,
        eccentricity: 0.0,
        semiMajorAxis: 0.02925,
        planetType: "Terrestrial"
      },
      {
        name: "TRAPPIST-1 f",
        hostStar: "TRAPPIST-1",
        distance: 39.5,
        orbitalPeriod: 9.21,
        radius: 1.045,
        mass: 1.039,
        equilibriumTemp: 219,
        discoveryYear: 2016,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0xffcc88,
        stellarMagnitude: 18.8,
        eccentricity: 0.0,
        semiMajorAxis: 0.03849,
        planetType: "Terrestrial"
      },
      {
        name: "TRAPPIST-1 g",
        hostStar: "TRAPPIST-1",
        distance: 39.5,
        orbitalPeriod: 12.35,
        radius: 1.127,
        mass: 1.321,
        equilibriumTemp: 198,
        discoveryYear: 2016,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0xffffaa,
        stellarMagnitude: 18.8,
        eccentricity: 0.0,
        semiMajorAxis: 0.04683,
        planetType: "Terrestrial"
      },
      {
        name: "TRAPPIST-1 h",
        hostStar: "TRAPPIST-1",
        distance: 39.5,
        orbitalPeriod: 18.77,
        radius: 0.715,
        mass: 0.326,
        equilibriumTemp: 173,
        discoveryYear: 2017,
        discoveryMethod: "Transit",
        inHabitableZone: false,
        color: 0xaaffff,
        stellarMagnitude: 18.8,
        eccentricity: 0.0,
        semiMajorAxis: 0.06189,
        planetType: "Terrestrial"
      },
      {
        name: "Kepler-452b",
        hostStar: "Kepler-452",
        distance: 1402,
        orbitalPeriod: 384.8,
        radius: 1.63,
        mass: 5.0, // estimated
        equilibriumTemp: 265,
        discoveryYear: 2015,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0x4ecdc4,
        stellarMagnitude: 13.426,
        eccentricity: 0.0,
        semiMajorAxis: 1.046,
        planetType: "Super Earth"
      },
      {
        name: "HD 209458 b",
        hostStar: "HD 209458",
        distance: 159,
        orbitalPeriod: 3.525,
        radius: 1.359, // Jupiter radii
        mass: 0.714, // Jupiter masses
        equilibriumTemp: 1449,
        discoveryYear: 1999,
        discoveryMethod: "Transit",
        inHabitableZone: false,
        color: 0xffe66d,
        stellarMagnitude: 7.65,
        eccentricity: 0.0,
        semiMajorAxis: 0.04707,
        planetType: "Hot Jupiter"
      },
      {
        name: "55 Cancri e",
        hostStar: "55 Cancri A",
        distance: 40.9,
        orbitalPeriod: 0.736,
        radius: 2.17,
        mass: 8.63,
        equilibriumTemp: 2273, // Extremely hot
        discoveryYear: 2004,
        discoveryMethod: "Radial Velocity",
        inHabitableZone: false,
        color: 0xff3300,
        stellarMagnitude: 5.95,
        eccentricity: 0.174,
        semiMajorAxis: 0.01544,
        planetType: "Super Earth"
      },
      {
        name: "GJ 1214 b",
        hostStar: "GJ 1214",
        distance: 48,
        orbitalPeriod: 1.58,
        radius: 2.678,
        mass: 6.26,
        equilibriumTemp: 555,
        discoveryYear: 2009,
        discoveryMethod: "Transit",
        inHabitableZone: false,
        color: 0x66aaff,
        stellarMagnitude: 14.67,
        eccentricity: 0.0,
        semiMajorAxis: 0.01411,
        planetType: "Mini Neptune"
      },
      {
        name: "Kepler-22b",
        hostStar: "Kepler-22",
        distance: 587,
        orbitalPeriod: 289.9,
        radius: 2.38,
        mass: 9.1, // estimated
        equilibriumTemp: 262,
        discoveryYear: 2011,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0x00cc99,
        stellarMagnitude: 11.664,
        eccentricity: 0.0,
        semiMajorAxis: 0.849,
        planetType: "Super Earth"
      },
      {
        name: "K2-18 b",
        hostStar: "K2-18",
        distance: 124,
        orbitalPeriod: 32.94,
        radius: 2.61,
        mass: 8.92,
        equilibriumTemp: 265,
        discoveryYear: 2015,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0x99ccff,
        stellarMagnitude: 13.31,
        eccentricity: 0.0,
        semiMajorAxis: 0.143,
        planetType: "Sub Neptune",
        hasWaterVapor: true
      },
      {
        name: "TOI-715 b",
        hostStar: "TOI-715",
        distance: 137,
        orbitalPeriod: 19.3,
        radius: 1.55,
        mass: 3.02,
        equilibriumTemp: 280,
        discoveryYear: 2024,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0xaaffcc,
        stellarMagnitude: 12.23,
        eccentricity: 0.0,
        semiMajorAxis: 0.083,
        planetType: "Super Earth"
      },
      {
        name: "LHS 1140 b",
        hostStar: "LHS 1140",
        distance: 48.6,
        orbitalPeriod: 24.7,
        radius: 1.727,
        mass: 5.6,
        equilibriumTemp: 230,
        discoveryYear: 2017,
        discoveryMethod: "Transit",
        inHabitableZone: true,
        color: 0x77ddaa,
        stellarMagnitude: 15.76,
        eccentricity: 0.0,
        semiMajorAxis: 0.0875,
        planetType: "Super Earth"
      },
      {
        name: "Wolf 1061c",
        hostStar: "Wolf 1061",
        distance: 13.8,
        orbitalPeriod: 17.9,
        radius: 1.66, // estimated
        mass: 4.25,
        equilibriumTemp: 223,
        discoveryYear: 2015,
        discoveryMethod: "Radial Velocity",
        inHabitableZone: true,
        color: 0xccaa88,
        stellarMagnitude: 10.07,
        eccentricity: 0.11,
        semiMajorAxis: 0.084,
        planetType: "Super Earth"
      },
      {
        name: "Gliese 667C c",
        hostStar: "Gliese 667C",
        distance: 23.6,
        orbitalPeriod: 28.15,
        radius: 1.54, // estimated
        mass: 3.709,
        equilibriumTemp: 277,
        discoveryYear: 2011,
        discoveryMethod: "Radial Velocity",
        inHabitableZone: true,
        color: 0xff9966,
        stellarMagnitude: 10.22,
        eccentricity: 0.02,
        semiMajorAxis: 0.125,
        planetType: "Super Earth"
      },
      {
        name: "HAT-P-7b",
        hostStar: "HAT-P-7",
        distance: 1044,
        orbitalPeriod: 2.204,
        radius: 1.363, // Jupiter radii
        mass: 1.776, // Jupiter masses
        equilibriumTemp: 2860,
        discoveryYear: 2008,
        discoveryMethod: "Transit",
        inHabitableZone: false,
        color: 0xffff00,
        stellarMagnitude: 10.5,
        eccentricity: 0.0,
        semiMajorAxis: 0.0377,
        planetType: "Hot Jupiter"
      },
      {
        name: "WASP-121b",
        hostStar: "WASP-121",
        distance: 850,
        orbitalPeriod: 1.275,
        radius: 1.865, // Jupiter radii
        mass: 1.183, // Jupiter masses
        equilibriumTemp: 2358,
        discoveryYear: 2015,
        discoveryMethod: "Transit",
        inHabitableZone: false,
        color: 0xff6600,
        stellarMagnitude: 10.4,
        eccentricity: 0.0,
        semiMajorAxis: 0.02544,
        planetType: "Hot Jupiter",
        hasAtmosphericEscape: true
      }
    ];

    // Create detailed exoplanet visualization with real NASA data
    realExoplanets.forEach((exo) => {
      // Scale visual size based on actual radius
      const visualRadius = Math.log(exo.radius + 1) * 3;
      const visualDistance = exo.distance * 100;
      
      // Random position in sphere around that distance
      const phi = Math.random() * Math.PI * 2;
      const cosTheta = 2 * Math.random() - 1;
      const theta = Math.acos(cosTheta);
      
      const position = new THREE.Vector3(
        visualDistance * Math.sin(theta) * Math.cos(phi),
        (Math.random() - 0.5) * visualDistance * 0.1, // Some height variation
        visualDistance * Math.sin(theta) * Math.sin(phi)
      );
      
      // Enhanced material based on planet characteristics
      const exoplanetMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          planetType: { value: exo.planetType },
          temperature: { value: exo.equilibriumTemp },
          inHabitableZone: { value: exo.inHabitableZone ? 1.0 : 0.0 },
          hasWater: { value: exo.hasWaterVapor ? 1.0 : 0.0 },
        },
        vertexShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          uniform float time;
          
          void main() {
            vPosition = position;
            vNormal = normal;
            
            // Slight pulsing for hot planets
            vec3 pos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          uniform float time;
          uniform float temperature;
          uniform float inHabitableZone;
          uniform float hasWater;
          
          void main() {
            vec3 baseColor = vec3(${((exo.color >> 16) & 0xFF) / 255.0}, ${((exo.color >> 8) & 0xFF) / 255.0}, ${(exo.color & 0xFF) / 255.0});
            
            // Temperature-based effects
            if (temperature > 2000.0) {
              // Ultra-hot planets - glowing
              baseColor = mix(baseColor, vec3(1.0, 0.3, 0.0), 0.7);
              float glow = pow(0.8 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
              baseColor += vec3(1.0, 0.5, 0.0) * glow;
            } else if (temperature > 1000.0) {
              // Hot planets - warm colors
              baseColor = mix(baseColor, vec3(1.0, 0.6, 0.2), 0.5);
            }
            
            // Habitable zone glow
            if (inHabitableZone > 0.5) {
              float habitableGlow = sin(time * 2.0) * 0.1 + 0.9;
              baseColor = mix(baseColor, vec3(0.2, 1.0, 0.3), 0.2 * habitableGlow);
            }
            
            // Water vapor indicator
            if (hasWater > 0.5) {
              float waterShimmer = sin(time * 3.0 + vPosition.x) * 0.1 + 0.9;
              baseColor = mix(baseColor, vec3(0.3, 0.7, 1.0), 0.3 * waterShimmer);
            }
            
            gl_FragColor = vec4(baseColor, 1.0);
          }
        `,
      });
      
      const exoplanet = new THREE.Mesh(
        new THREE.IcosahedronGeometry(visualRadius, 3),
        exoplanetMaterial
      );
      
      exoplanet.position.copy(position);
      
      // Store comprehensive NASA data
      exoplanet.userData = {
        ...exo,
        isExoplanet: true,
        visualRadius: visualRadius,
        realData: exo,
        materials: [exoplanetMaterial]
      };
      
      scene.add(exoplanet);
      
      // Add orbital path for close exoplanets
      if (exo.distance < 100) {
        const orbitRadius = exo.semiMajorAxis * 1000; // Scale for visibility
        if (orbitRadius > 10) {
          const curve = new THREE.EllipseCurve(
            0, 0,
            orbitRadius, orbitRadius * (1 - exo.eccentricity),
            0, 2 * Math.PI
          );
          const points = curve.getPoints(128);
          const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
          const orbitMaterial = new THREE.LineBasicMaterial({
            color: exo.inHabitableZone ? 0x00ff00 : 0x666666,
            opacity: 0.3,
            transparent: true,
          });
          const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
          orbit.rotation.x = Math.PI / 2;
          orbit.position.copy(position);
          scene.add(orbit);
        }
      }
      
      // Add host star marker for significant systems
      if (exo.name.includes("TRAPPIST-1") && exo.name === "TRAPPIST-1 b") {
        const hostStar = new THREE.Mesh(
          new THREE.SphereGeometry(8, 16, 16),
          new THREE.MeshBasicMaterial({
            color: 0xff4400,
            emissive: 0xff2200,
            emissiveIntensity: 0.5
          })
        );
        hostStar.position.copy(position);
        hostStar.userData = {
          name: exo.hostStar,
          magnitude: exo.stellarMagnitude,
          distance: exo.distance,
          isHostStar: true
        };
        scene.add(hostStar);
      }
    });

    // Known nebulae from NASA catalog
    const realNebulae = [
      {
        name: "Orion Nebula",
        pos: new THREE.Vector3(1344, 0, 0),
        color1: 0xff0080,
        color2: 0x0080ff,
        size: 200,
      },
      {
        name: "Eagle Nebula",
        pos: new THREE.Vector3(7000, 500, 1000),
        color1: 0xff6600,
        color2: 0xffff00,
        size: 300,
      },
      {
        name: "Crab Nebula",
        pos: new THREE.Vector3(6523, -200, 500),
        color1: 0x00ff80,
        color2: 0xff0080,
        size: 150,
      },
      {
        name: "Helix Nebula",
        pos: new THREE.Vector3(700, 100, -300),
        color1: 0x00ffff,
        color2: 0xff00ff,
        size: 180,
      },
      {
        name: "Rosette Nebula",
        pos: new THREE.Vector3(5200, -300, 800),
        color1: 0xff0066,
        color2: 0x6600ff,
        size: 250,
      },
    ];

    realNebulae.forEach((neb) => {
      const nebula = createNebula(
        neb.pos,
        new THREE.Color(neb.color1),
        new THREE.Color(neb.color2),
        neb.size
      );
      scene.add(nebula);
    });

    // Known galaxies
    const knownGalaxies = [
      {
        name: "Andromeda (M31)",
        pos: new THREE.Vector3(250000, 20000, 100000),
        size: 2000,
      },
      {
        name: "Triangulum (M33)",
        pos: new THREE.Vector3(300000, -50000, 150000),
        size: 1000,
      },
      {
        name: "Large Magellanic Cloud",
        pos: new THREE.Vector3(16000, -30000, -50000),
        size: 500,
      },
      {
        name: "Small Magellanic Cloud",
        pos: new THREE.Vector3(20000, -40000, -60000),
        size: 300,
      },
      {
        name: "Whirlpool (M51)",
        pos: new THREE.Vector3(2300000, 100000, 500000),
        size: 1500,
      },
      {
        name: "Sombrero (M104)",
        pos: new THREE.Vector3(2900000, -200000, 800000),
        size: 1200,
      },
    ];

    knownGalaxies.forEach((gal) => {
      const galaxyGroup = new THREE.Group();

      // Create more detailed galaxy structure
      const coreGeometry = new THREE.SphereGeometry(gal.size * 0.2, 16, 16);
      const coreMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffaa,
      });
      const core = new THREE.Mesh(coreGeometry, coreMaterial);
      galaxyGroup.add(core);

      // Spiral arms
      const armGeometry = new THREE.BufferGeometry();
      const armPositions = new Float32Array(5000 * 3);
      const armColors = new Float32Array(5000 * 3);

      for (let i = 0; i < 5000; i++) {
        const armIndex = i % 4;
        const armAngle = (armIndex / 4) * Math.PI * 2;
        const radius = Math.random() * gal.size;
        const spiralAngle = armAngle + radius * 0.002;

        const i3 = i * 3;
        armPositions[i3] = Math.cos(spiralAngle) * radius;
        armPositions[i3 + 1] = (Math.random() - 0.5) * gal.size * 0.1;
        armPositions[i3 + 2] = Math.sin(spiralAngle) * radius;

        const brightness = 1 - (radius / gal.size) * 0.7;
        armColors[i3] = brightness * 0.8;
        armColors[i3 + 1] = brightness * 0.8;
        armColors[i3 + 2] = brightness;
      }

      armGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(armPositions, 3)
      );
      armGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(armColors, 3)
      );

      const armMaterial = new THREE.PointsMaterial({
        size: 10,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: false,
      });

      const arms = new THREE.Points(armGeometry, armMaterial);
      galaxyGroup.add(arms);

      galaxyGroup.position.copy(gal.pos);
      galaxyGroup.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        0
      );
      scene.add(galaxyGroup);
    });

    // Asteroid belt objects (named asteroids)
    const namedAsteroids = [
      { name: "Ceres", radius: 0.5, distance: 220 },
      { name: "Vesta", radius: 0.3, distance: 210 },
      { name: "Pallas", radius: 0.3, distance: 230 },
      { name: "Hygiea", radius: 0.2, distance: 240 },
    ];

    namedAsteroids.forEach((ast) => {
      const asteroid = new THREE.Mesh(
        new THREE.IcosahedronGeometry(ast.radius * 5, 1),
        new THREE.MeshPhongMaterial({ color: 0x888888, flatShading: true })
      );
      const angle = Math.random() * Math.PI * 2;
      asteroid.position.set(
        Math.cos(angle) * ast.distance,
        (Math.random() - 0.5) * 5,
        Math.sin(angle) * ast.distance
      );
      scene.add(asteroid);
    });

    // Kuiper Belt objects
    const kuiperBeltObjects = [
      { name: "Pluto", radius: 2, distance: 900, color: 0xaa8866 },
      { name: "Eris", radius: 1.8, distance: 1000, color: 0xcccccc },
      { name: "Makemake", radius: 1.5, distance: 950, color: 0xffaa88 },
      { name: "Haumea", radius: 1.3, distance: 980, color: 0xaaaaaa },
    ];

    kuiperBeltObjects.forEach((kbo) => {
      const obj = new THREE.Mesh(
        new THREE.SphereGeometry(kbo.radius, 16, 16),
        new THREE.MeshPhongMaterial({ color: kbo.color })
      );
      obj.userData = {
        name: kbo.name,
        angle: Math.random() * Math.PI * 2,
        distance: kbo.distance,
        speed: 0.05,
      };
      planets.push(obj);
      scene.add(obj);

      // Orbit
      const curve = new THREE.EllipseCurve(
        0,
        0,
        kbo.distance,
        kbo.distance,
        0,
        2 * Math.PI
      );
      const points = curve.getPoints(64);
      const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const orbitMaterial = new THREE.LineBasicMaterial({
        color: 0x333333,
        opacity: 0.2,
        transparent: true,
      });
      const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
      orbit.rotation.x = Math.PI / 2;
      scene.add(orbit);
    });

    // Saturn's rings
    const saturnRingGeometry = new THREE.RingGeometry(15, 25, 64);
    const saturnRingMaterial = new THREE.MeshBasicMaterial({
      color: 0xffdd99,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.7,
    });
    const saturnRings = new THREE.Mesh(saturnRingGeometry, saturnRingMaterial);
    saturnRings.rotation.x = Math.PI / 2;
    planets[5].add(saturnRings); // Saturn is index 5

    // Jupiter's moons
    const jupiterMoons = [
      { name: "Io", radius: 0.5, distance: 15, color: 0xffff99 },
      { name: "Europa", radius: 0.4, distance: 20, color: 0xaaffff },
      { name: "Ganymede", radius: 0.6, distance: 25, color: 0xaa8855 },
      { name: "Callisto", radius: 0.5, distance: 30, color: 0x665544 },
    ];

    jupiterMoons.forEach((moon) => {
      const moonMesh = new THREE.Mesh(
        new THREE.SphereGeometry(moon.radius, 8, 8),
        new THREE.MeshPhongMaterial({ color: moon.color })
      );
      moonMesh.userData = {
        angle: Math.random() * Math.PI * 2,
        distance: moon.distance,
        speed: 5,
      };
      planets[4].add(moonMesh); // Jupiter is index 4
    });

    // Voyager 1 & 2 positions (approximate)
    const voyager1 = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 0.1, 0.1),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    voyager1.position.set(15000, 1000, 5000);
    scene.add(voyager1);

    const voyager2 = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 0.1, 0.1),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    voyager2.position.set(12000, -800, 4000);
    scene.add(voyager2);

    // Black hole at galactic center
    const blackHoleGeometry = new THREE.SphereGeometry(50, 32, 32);
    const blackHoleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
      },
      vertexShader: `
        varying vec3 vPosition;
        void main() {
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        varying vec3 vPosition;
        void main() {
          float dist = length(vPosition);
          float intensity = 1.0 - smoothstep(0.0, 50.0, dist);
          vec3 color = vec3(0.0);
          
          // Event horizon effect
          float swirl = sin(atan(vPosition.y, vPosition.x) * 5.0 + time * 2.0) * 0.5 + 0.5;
          color += vec3(0.5, 0.0, 1.0) * swirl * intensity;
          
          gl_FragColor = vec4(color, intensity);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending,
    });
    const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
    blackHole.position.set(0, 0, -50000);
    scene.add(blackHole);

    // Accretion disk
    const diskGeometry = new THREE.RingGeometry(100, 300, 64);
    const diskMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        varying vec2 vUv;
        void main() {
          float radius = length(vUv - 0.5) * 2.0;
          float angle = atan(vUv.y - 0.5, vUv.x - 0.5);
          
          float spiral = sin(angle * 10.0 - radius * 20.0 + time * 5.0) * 0.5 + 0.5;
          vec3 color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 0.0), spiral);
          
          float intensity = 1.0 - smoothstep(0.3, 1.0, radius);
          
          gl_FragColor = vec4(color * intensity, intensity);
        }
      `,
      side: THREE.DoubleSide,
      transparent: true,
      blending: THREE.AdditiveBlending,
    });
    const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
    accretionDisk.rotation.x = Math.PI / 2;
    blackHole.add(accretionDisk);

    // O(1) LOD System with Improved Planetary Entry Detection
    const updateLODSystem = () => {
      const distance = camera.position.length(); // Distance from origin in light-years
      let newLodLevel = 0;
      let newScale = "galactic";

      // Update universe details based on camera position
      updateUniverseDetails(camera.position);

      // Improved planetary entry detection with better collision detection
      let enteredPlanet = null;
      let closestPlanet = null;
      let closestDistance = Infinity;

      planets.forEach((planet) => {
        const planetDistance = camera.position.distanceTo(planet.position);
        const planetRadius = planet.userData.radius;
        const entryRadius = planetRadius * planetarySystem.current.entryThreshold;
        
        // Track closest planet for debugging
        if (planetDistance < closestDistance) {
          closestDistance = planetDistance;
          closestPlanet = planet;
        }
        
        // Check if camera is within entry threshold
        if (planetDistance < entryRadius) {
          enteredPlanet = planet;
          console.log(`Camera within ${planet.userData.name} entry zone: ${planetDistance.toFixed(2)} < ${entryRadius.toFixed(2)}`);
        }
      });

      // Debug: Show closest planet info
      if (closestPlanet && !planetarySystem.current.isInsidePlanet) {
        const debugDistance = camera.position.distanceTo(closestPlanet.position);
        const debugRadius = closestPlanet.userData.radius * planetarySystem.current.entryThreshold;
        if (debugDistance < debugRadius * 2) { // Only log when getting close
          console.log(`Approaching ${closestPlanet.userData.name}: distance ${debugDistance.toFixed(2)}, entry at ${debugRadius.toFixed(2)}`);
        }
      }

      // Handle planetary entry
      if (enteredPlanet && !planetarySystem.current.isInsidePlanet) {
        console.log(`🪐 ENTERING PLANET: ${enteredPlanet.userData.name}`);
        
        planetarySystem.current.isInsidePlanet = true;
        planetarySystem.current.currentPlanet = enteredPlanet;
        
        // Create detailed surface and sky for this planet
        const detailedSurface = createPlanetarySurface(enteredPlanet.userData);
        const planetarySky = createPlanetarySky(enteredPlanet.userData);
        
        detailedSurface.position.copy(enteredPlanet.position);
        planetarySky.position.copy(enteredPlanet.position);
        
        lodObjects.current.planetary = detailedSurface;
        planetarySystem.current.skybox = planetarySky;
        
        scene.add(detailedSurface);
        scene.add(planetarySky);
        
        // Lock camera to surface
        const planetRadius = enteredPlanet.userData.radius;
        const cameraDirection = camera.position.clone().sub(enteredPlanet.position).normalize();
        const surfacePoint = enteredPlanet.position.clone()
          .add(cameraDirection.multiplyScalar(planetRadius + 0.002));
        
        cameraState.current.position.copy(surfacePoint);
        planetarySystem.current.surfacePosition.copy(surfacePoint);
        planetarySystem.current.lockedToSurface = true;
        
        newLodLevel = 0; // Force surface level detail
        newScale = "planetary_surface";
        
        // Stop any movement velocity
        cameraState.current.velocity.set(0, 0, 0);
      }
      
      // Handle automatic planetary exit (when too far away)
      else if (planetarySystem.current.isInsidePlanet && planetarySystem.current.currentPlanet) {
        const currentPlanet = planetarySystem.current.currentPlanet;
        const currentDistance = camera.position.distanceTo(currentPlanet.position);
        const exitRadius = currentPlanet.userData.radius * planetarySystem.current.exitThreshold;
        
        if (currentDistance > exitRadius && !enteredPlanet) {
          console.log(`🚀 AUTO-EXITING PLANET: ${currentPlanet.userData.name} (distance: ${currentDistance.toFixed(2)} > ${exitRadius.toFixed(2)})`);
          exitPlanetMode.current();
        }
      }

      // Regular LOD determination when not inside planet
      if (!planetarySystem.current.isInsidePlanet) {
        if (distance < LOD_THRESHOLDS.ATMOSPHERE) {
          newLodLevel = 0; newScale = "atmosphere";
        } else if (distance < LOD_THRESHOLDS.SURFACE) {
          newLodLevel = 1; newScale = "surface";
        } else if (distance < LOD_THRESHOLDS.ORBITAL) {
          newLodLevel = 2; newScale = "orbital";
        } else if (distance < LOD_THRESHOLDS.STELLAR) {
          newLodLevel = 3; newScale = "stellar";
        } else if (distance < LOD_THRESHOLDS.GALACTIC) {
          newLodLevel = 4; newScale = "galactic";
        } else if (distance < LOD_THRESHOLDS.LOCAL_GROUP) {
          newLodLevel = 5; newScale = "local_group";
        } else if (distance < LOD_THRESHOLDS.COSMIC_WEB) {
          newLodLevel = 6; newScale = "cosmic_web";
        } else {
          newLodLevel = 7; newScale = "observable_universe";
        }
      }

      // Only update if LOD level changed (O(1) optimization)
      if (newLodLevel !== cameraState.current.lastLodLevel) {
        setCurrentScale(newScale);
        setLodLevel(newLodLevel);
        cameraState.current.lastLodLevel = newLodLevel;

        // Update fog based on scale
        const fogDensities = [0.001, 0.0001, 0.00003, 0.00001, 0.000001, 0.0000001, 0.00000001, 0.000000001];
        scene.fog.density = planetarySystem.current.isInsidePlanet ? 0.0001 : fogDensities[newLodLevel];

        // LOD visibility switching (O(1) per object type)
        // Atmospheric detail (only visible when very close)
        if (lodObjects.current.atmosphere) {
          lodObjects.current.atmosphere.visible = newLodLevel <= 1 && !planetarySystem.current.isInsidePlanet;
        }

        // Planetary objects (visible in close to orbital scales, hidden when inside)
        planets.forEach((planet) => {
          planet.visible = newLodLevel <= 2 && !planetarySystem.current.isInsidePlanet;
        });

        // Solar system objects (hidden when on surface)
        if (asteroids) asteroids.visible = newLodLevel <= 2 && !planetarySystem.current.isInsidePlanet;
        if (comet) comet.visible = newLodLevel <= 2 && !planetarySystem.current.isInsidePlanet;

        // Stellar objects
        if (starsMaterial) {
          starsMaterial.uniforms.scale.value = Math.min(5, Math.max(0.1, newLodLevel));
        }

        // Galactic objects (milkyWay is always visible as it's the center)
        galaxies.forEach((galaxy) => {
          galaxy.visible = newLodLevel >= 4 && !planetarySystem.current.isInsidePlanet;
        });

        // CMB (only visible at largest scales)
        if (lodObjects.current.cmb) {
          lodObjects.current.cmb.visible = newLodLevel >= 5 && !planetarySystem.current.isInsidePlanet;
        }

        // JWST nebulae visibility based on scale
        jwstNebulae.forEach((nebula) => {
          nebula.visible = newLodLevel >= 2 && newLodLevel <= 4 && !planetarySystem.current.isInsidePlanet;
        });

        // Dynamic detail adjustment for performance
        const detailLevels = [64, 32, 16, 8, 4, 2, 1];
        const currentDetail = detailLevels[newLodLevel];
        
        // Update shader detail uniforms
        if (sun && sun.material && sun.material.uniforms) {
          sun.material.uniforms.detail.value = currentDetail;
        }

        const status = planetarySystem.current.isInsidePlanet ? 
          `Inside ${planetarySystem.current.currentPlanet?.userData.name}` :
          `LOD Level: ${newLodLevel}, Scale: ${newScale}, Distance: ${distance.toExponential(2)}km`;
        console.log(status);
      }

      // Surface camera locking when inside planet
      if (planetarySystem.current.lockedToSurface && planetarySystem.current.currentPlanet) {
        const planet = planetarySystem.current.currentPlanet;
        const planetCenter = planet.position;
        const currentPos = camera.position.clone().sub(planetCenter);
        const planetRadius = planet.userData.radius;
        
        // Keep camera at surface level
        const surfacePos = currentPos.normalize().multiplyScalar(planetRadius + 0.002);
        cameraState.current.position.copy(surfacePos.add(planetCenter));
        
        // Update surface normal for gravity simulation
        planetarySystem.current.surfaceNormal.copy(currentPos.normalize());
      }
    };

    // Store cleanup references
    let velocityInterval = null;
    let keydownHandler = null;
    let keyupHandler = null;

    // Mobile touch controls
    if (isMobile) {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchStartTime = 0;
      let lastPinchDistance = 0;
      let isPinching = false;
      let pinchEndTime = 0;

      renderer.domElement.addEventListener("touchstart", (e) => {
        e.preventDefault();

        if (e.touches.length === 1) {
          if (Date.now() - pinchEndTime < 300) return;

          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          touchStartTime = Date.now();
        } else if (e.touches.length === 2) {
          isPinching = true;
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
        }
      });

      renderer.domElement.addEventListener("touchmove", (e) => {
        e.preventDefault();

        if (e.touches.length === 1 && !isPinching) {
          if (Date.now() - pinchEndTime < 300) return;

          const deltaX = e.touches[0].clientX - touchStartX;
          const deltaY = e.touches[0].clientY - touchStartY;

          const spherical = new THREE.Spherical();
          const offset = cameraState.current.lookAt
            .clone()
            .sub(cameraState.current.position);
          spherical.setFromVector3(offset);

          spherical.theta -= deltaX * 0.01;
          spherical.phi += deltaY * 0.01;
          spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

          offset.setFromSpherical(spherical);
          cameraState.current.lookAt
            .copy(cameraState.current.position)
            .add(offset);

          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        } else if (e.touches.length === 2 && lastPinchDistance > 0) {
          isPinching = true;
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const currentDistance = Math.sqrt(dx * dx + dy * dy);

          const scale = (currentDistance - lastPinchDistance) * 0.5;
          const direction = cameraState.current.lookAt
            .clone()
            .sub(cameraState.current.position)
            .normalize();

          const currentDist = cameraState.current.position.length();
          const moveScale =
            currentDist < 100
              ? scale * 0.1
              : currentDist < 1000
              ? scale
              : currentDist < 10000
              ? scale * 10
              : currentDist < 100000
              ? scale * 100
              : scale * 1000;

          cameraState.current.position.addScaledVector(direction, moveScale);
          cameraState.current.lookAt.addScaledVector(direction, moveScale);

          lastPinchDistance = currentDistance;
        }
      });

      renderer.domElement.addEventListener("touchend", (e) => {
        if (isPinching && e.touches.length < 2) {
          isPinching = false;
          pinchEndTime = Date.now();
          lastPinchDistance = 0;
        } else if (e.touches.length === 0 && !isPinching) {
          const touchDuration = Date.now() - touchStartTime;
          if (touchDuration < 200 && Date.now() - pinchEndTime > 300) {
            const direction = cameraState.current.lookAt
              .clone()
              .sub(cameraState.current.position)
              .normalize();
            const currentDist = cameraState.current.position.length();
            const speed =
              currentDist < 10
                ? 0.3    // Gentle close up
                : currentDist < 100
                ? 1.5    // Faster for planetary
                : currentDist < 1000
                ? 6      // Good speed for stellar
                : currentDist < 10000
                ? 30     // Faster for galactic
                : currentDist < 100000
                ? 150    // Fast for inter-galactic
                : 600;   // Max speed for universe scale
            cameraState.current.targetVelocity.copy(direction).multiplyScalar(speed);
          }
        }
      });
    } else {
      // Desktop controls
      let isPointerLocked = false;
      const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        shift: false,
        space: false,
      };

      renderer.domElement.addEventListener("click", () => {
        renderer.domElement.requestPointerLock();
      });

      document.addEventListener("pointerlockchange", () => {
        isPointerLocked = document.pointerLockElement === renderer.domElement;
      });

      document.addEventListener("mousemove", (e) => {
        if (!isPointerLocked) return;

        const spherical = new THREE.Spherical();
        const offset = cameraState.current.lookAt
          .clone()
          .sub(cameraState.current.position);
        spherical.setFromVector3(offset);

        spherical.theta -= e.movementX * 0.002;
        spherical.phi += e.movementY * 0.002;
        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

        offset.setFromSpherical(spherical);
        cameraState.current.lookAt
          .copy(cameraState.current.position)
          .add(offset);
      });

      keydownHandler = (e) => {
        switch (e.key.toLowerCase()) {
          case "w":
            keys.w = true;
            break;
          case "a":
            keys.a = true;
            break;
          case "s":
            keys.s = true;
            break;
          case "d":
            keys.d = true;
            break;
          case " ":
            e.preventDefault();
            keys.space = true;
            break;
          case "shift":
            keys.shift = true;
            break;
        }
      };

      keyupHandler = (e) => {
        switch (e.key.toLowerCase()) {
          case "w":
            keys.w = false;
            break;
          case "a":
            keys.a = false;
            break;
          case "s":
            keys.s = false;
            break;
          case "d":
            keys.d = false;
            break;
          case " ":
            e.preventDefault();
            keys.space = false;
            break;
          case "shift":
            keys.shift = false;
            break;
          case "escape":
            if (document.pointerLockElement) {
              document.exitPointerLock();
            }
            break;
        }
      };

      document.addEventListener("keydown", keydownHandler);
      document.addEventListener("keyup", keyupHandler);

      // Desktop scroll handling - much smoother and slower
      renderer.domElement.addEventListener("wheel", (e) => {
        e.preventDefault();
        
        const direction = cameraState.current.lookAt
          .clone()
          .sub(cameraState.current.position)
          .normalize();
        
        const currentDist = cameraState.current.position.length();
        
        // Faster speed scaling for forward/backward scroll movement
        const baseSpeed = currentDist < 10
          ? 0.06    // Gentle close up
          : currentDist < 100
          ? 0.3     // Faster for planetary
          : currentDist < 1000
          ? 1.5     // Good speed for stellar
          : currentDist < 10000
          ? 6       // Faster for galactic
          : currentDist < 100000
          ? 30      // Fast for inter-galactic
          : currentDist < 1000000
          ? 150     // Very fast for galaxy clusters
          : 600;    // Max for universe scale
        
        // Normalize wheel delta and apply movement (3x faster than before)
        const wheelDirection = e.deltaY > 0 ? 1 : -1; // Scroll down = zoom out, scroll up = zoom in
        const movement = direction.clone().multiplyScalar(wheelDirection * baseSpeed * 0.9);
        
        // Add to target velocity for smooth interpolation
        cameraState.current.targetVelocity.add(movement);
      });

      const updateVelocity = () => {
        if (!isPointerLocked) return;

        const forward = cameraState.current.lookAt
          .clone()
          .sub(cameraState.current.position)
          .normalize();
        const right = new THREE.Vector3()
          .crossVectors(forward, new THREE.Vector3(0, 1, 0))
          .normalize();

        const movement = new THREE.Vector3(0, 0, 0);
        const forwardMovement = new THREE.Vector3(0, 0, 0);
        const sideMovement = new THREE.Vector3(0, 0, 0);
        
        // Handle forward/backward separately for faster movement
        if (keys.w) forwardMovement.add(forward);
        if (keys.s) forwardMovement.sub(forward);
        
        // Handle side movement at normal speed
        if (keys.a) sideMovement.sub(right);
        if (keys.d) sideMovement.add(right);
        if (keys.space) sideMovement.y += 1;
        if (keys.shift) sideMovement.y -= 1;

        const currentDist = cameraState.current.position.length();
        
        // Base speed for side movements (normal speed)
        const sideSpeed =
          currentDist < 10         ? 0.1    :  // Very slow close up
          currentDist < 100        ? 0.5    :  // Slow for stellar
          currentDist < 1000       ? 2      :  // Moderate for local 
          currentDist < 10000      ? 10     :  // Medium for galactic
          currentDist < 100000     ? 50     :  // Faster for inter-galactic
          currentDist < 1000000    ? 200    :  // Fast for galaxy clusters
          500;                               // Max speed for universe scale
        
        // Forward/backward speed (3x faster for better navigation)
        const forwardSpeed = sideSpeed * 3;

        if (forwardMovement.length() > 0) {
          forwardMovement.normalize().multiplyScalar(forwardSpeed);
          movement.add(forwardMovement);
        }
        
        if (sideMovement.length() > 0) {
          sideMovement.normalize().multiplyScalar(sideSpeed);
          movement.add(sideMovement);
        }

        if (movement.length() > 0) {
          // Use target velocity for smoother movement
          cameraState.current.targetVelocity.copy(movement);
        } else {
          // Gradually slow down when no input
          cameraState.current.targetVelocity.multiplyScalar(0.9);
        }
      };

      velocityInterval = setInterval(updateVelocity, 16);
    }

    // Animation
    let time = 0;
    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);
      time += 0.016 * timeSpeed;

      // Update sun
      sun.material.uniforms.time.value = time;
      const distance = camera.position.length();
      sun.material.uniforms.detail.value = Math.max(
        0.1,
        Math.min(10, 1000 / distance)
      );

      // Update planets
      planets.forEach((planet) => {
        planet.userData.angle += planet.userData.speed * 0.01 * timeSpeed;
        planet.position.x =
          Math.cos(planet.userData.angle) * planet.userData.distance;
        planet.position.z =
          Math.sin(planet.userData.angle) * planet.userData.distance;
        planet.rotation.y += 0.01;
      });

      // Update comet
      comet.userData.angle += comet.userData.speed * 0.003 * timeSpeed;
      comet.position.x = Math.cos(comet.userData.angle) * comet.userData.radius;
      comet.position.z = Math.sin(comet.userData.angle) * comet.userData.radius;
      comet.position.y =
        Math.sin(comet.userData.angle * comet.userData.verticalSpeed) * 50;

      const cometToSun = new THREE.Vector3()
        .subVectors(sun.position, comet.position)
        .normalize();
      comet.lookAt(comet.position.clone().sub(cometToSun));

      // Update JWST nebulae
      jwstNebulae.forEach((nebula) => {
        if (nebula.userData) {
          nebula.userData.coreMaterial.uniforms.time.value = time;
          nebula.userData.wispsMaterial.uniforms.time.value = time;
          nebula.userData.starsMaterial.uniforms.time.value = time;

          // Adjust detail based on distance
          const dist = camera.position.distanceTo(nebula.position);
          const scale = Math.max(0.5, Math.min(2.0, 1000 / dist));
          nebula.userData.coreMaterial.uniforms.scale.value = scale;
        }
      });

      // Lightning effects
      if (Math.random() < 0.02) {
        const lightning = createLightning();
        lightningBolts.push(lightning);
        scene.add(lightning);
      }

      for (let i = lightningBolts.length - 1; i >= 0; i--) {
        const bolt = lightningBolts[i];
        bolt.userData.lifetime += 0.05;
        bolt.material.opacity = Math.max(0, 0.8 - bolt.userData.lifetime);

        if (bolt.userData.lifetime > 1) {
          scene.remove(bolt);
          lightningBolts.splice(i, 1);
        }
      }

      // Rotate all galaxies
      galaxies.forEach((galaxy) => {
        galaxy.rotation.y += 0.00001 * timeSpeed;
      });

      // Also rotate known galaxies
      knownGalaxies.forEach((gal, index) => {
        if (scene.children[index]) {
          scene.traverse((child) => {
            if (child.type === "Group" && child.position.equals(gal.pos)) {
              child.rotation.y += 0.00001 * timeSpeed;
            }
          });
        }
      });

      // Update Jupiter's moons
      if (planets[4] && planets[4].children) {
        planets[4].children.forEach((moon) => {
          if (moon.userData && moon.userData.distance) {
            moon.userData.angle += moon.userData.speed * 0.01 * timeSpeed;
            moon.position.x =
              Math.cos(moon.userData.angle) * moon.userData.distance;
            moon.position.z =
              Math.sin(moon.userData.angle) * moon.userData.distance;
          }
        });
      }

      // Update black hole
      if (blackHole) {
        blackHole.material.uniforms.time.value = time;
        blackHole.children.forEach((child) => {
          if (child.material && child.material.uniforms) {
            child.material.uniforms.time.value = time;
          }
        });
      }

      // Apply smooth velocity with better damping
      cameraState.current.velocity.lerp(cameraState.current.targetVelocity, 0.08); // Smooth interpolation
      cameraState.current.position.add(cameraState.current.velocity);
      cameraState.current.lookAt.add(cameraState.current.velocity);
      cameraState.current.velocity.multiplyScalar(cameraState.current.smoothing); // Configurable damping

      // Update camera
      camera.position.copy(cameraState.current.position);
      camera.lookAt(cameraState.current.lookAt);

      // Update LOD system
      updateLODSystem();

      // Update atmospheric materials
      if (lodObjects.current.atmosphere && lodObjects.current.atmosphere.visible) {
        lodObjects.current.atmosphere.userData.materials.forEach(material => {
          if (material.uniforms && material.uniforms.time) {
            material.uniforms.time.value = time;
          }
        });
      }

      // Update CMB material
      if (lodObjects.current.cmb && lodObjects.current.cmb.visible) {
        lodObjects.current.cmb.userData.material.uniforms.time.value = time;
      }

      // Update Milky Way galaxy materials
      if (milkyWay && milkyWay.userData.materials) {
        milkyWay.userData.materials.forEach(material => {
          if (material.uniforms && material.uniforms.time) {
            material.uniforms.time.value = time;
          }
        });
      }

      // Update VFX materials
      if (vfxSystem.spaceDust && vfxSystem.spaceDust.material.uniforms) {
        vfxSystem.spaceDust.material.uniforms.time.value = time;
        vfxSystem.spaceDust.material.uniforms.cameraPosition.value.copy(camera.position);
      }
      
      if (vfxSystem.starfield && vfxSystem.starfield.material.uniforms) {
        vfxSystem.starfield.material.uniforms.time.value = time;
        vfxSystem.starfield.material.uniforms.cameraPosition.value.copy(camera.position);
      }

      // Update planetary surface materials when inside planet
      if (planetarySystem.current.isInsidePlanet) {
        if (lodObjects.current.planetary) {
          lodObjects.current.planetary.userData.materials.forEach(material => {
            if (material.uniforms) {
              if (material.uniforms.time) material.uniforms.time.value = time;
              if (material.uniforms.sunPosition && sun) {
                material.uniforms.sunPosition.value.copy(sun.position);
              }
            }
          });
        }
        
        if (planetarySystem.current.skybox) {
          planetarySystem.current.skybox.userData.materials.forEach(material => {
            if (material.uniforms) {
              if (material.uniforms.time) material.uniforms.time.value = time;
              if (material.uniforms.sunPosition && sun) {
                material.uniforms.sunPosition.value.copy(sun.position);
              }
              if (material.uniforms.planetPosition && planetarySystem.current.currentPlanet) {
                material.uniforms.planetPosition.value.copy(planetarySystem.current.currentPlanet.position);
              }
            }
          });
        }
      }

      renderer.render(scene, camera);
    };

    animate();

    // Handle resize
    const handleResize = () => {
      const width = mountRef.current.clientWidth;
      const height = mountRef.current.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    };
    window.addEventListener("resize", handleResize);

    // Cleanup
    return () => {
      cancelAnimationFrame(frameRef.current);
      window.removeEventListener("resize", handleResize);

      // Clean up desktop controls
      if (velocityInterval) {
        clearInterval(velocityInterval);
      }
      if (keydownHandler) {
        document.removeEventListener("keydown", keydownHandler);
      }
      if (keyupHandler) {
        document.removeEventListener("keyup", keyupHandler);
      }

      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [timeSpeed, isMobile]);

  // Get scale label with scientific accuracy
  const getScaleLabel = () => {
    const distance = cameraState.current.position.length();
    
    // Special case for planetary surface mode
    if (planetarySystem.current.isInsidePlanet && planetarySystem.current.currentPlanet) {
      const planetName = planetarySystem.current.currentPlanet.userData.name;
      const altitude = (distance - planetarySystem.current.currentPlanet.userData.radius) * 1000;
      return `🪐 On ${planetName} Surface (${altitude.toFixed(0)}m altitude)`;
    }
    
    switch (currentScale) {
      case "atmosphere":
        return `🌤️ Atmospheric Scale (${(distance * 9.461e15).toFixed(0)}m)`;
      case "surface":
        return `🌍 Planetary Surface (${(distance * 9.461e12).toFixed(1)}km)`;
      case "orbital":
        return `🛰️ Orbital Scale (${(distance * 9.461e9).toFixed(1)}k km)`;
      case "stellar":
        return `⭐ Stellar Neighborhood (${distance.toFixed(2)} ly)`;
      case "galactic":
        return `🌌 Galactic Scale (${(distance / 1000).toFixed(1)}k ly)`;
      case "local_group":
        return `🌌 Local Galaxy Group (${(distance / 1000000).toFixed(1)}M ly)`;
      case "cosmic_web":
        return `🕸️ Cosmic Web (${(distance / 1000000).toFixed(1)}M ly)`;
      case "observable_universe":
        return `🌠 Observable Universe (${(distance / 1000000000).toFixed(1)}B ly)`;
      default:
        return "🚀 Space";
    }
  };

  return (
    <div className="w-full h-screen relative bg-black overflow-hidden">
      <div ref={mountRef} className="w-full h-full" />

      {/* Minimal UI */}
      {isMobile ? (
        <>
          {/* Mobile UI */}
          <div className="absolute top-2 left-2 bg-black/50 backdrop-blur px-2 py-1 rounded text-white text-xs">
            <div>{getScaleLabel()}</div>
            <div className="text-gray-400">
              {planetarySystem.current.isInsidePlanet ? 
                "Surface Mode: Drag: Look • Pinch: Move on surface" :
                "Tap: Forward • Drag: Look • Pinch: Move"
              }
            </div>
            {planetarySystem.current.isInsidePlanet && (
              <div className="text-yellow-400 mt-1">
                ⚠️ Camera locked to {planetarySystem.current.currentPlanet?.userData.name} surface
              </div>
            )}
          </div>

          {/* Exit Planet Button - Mobile */}
          {planetarySystem.current.isInsidePlanet && (
            <div className="absolute top-20 left-2 right-2">
              <button
                onClick={() => exitPlanetMode.current?.()}
                className="w-full bg-red-600/80 hover:bg-red-700/80 backdrop-blur px-3 py-2 rounded text-white text-sm font-bold transition-colors"
              >
                🚀 Exit {planetarySystem.current.currentPlanet?.userData.name}
              </button>
            </div>
          )}
          
          <div className="absolute bottom-2 left-2 right-2 bg-black/50 backdrop-blur p-2 rounded-lg">
            <div className="text-white text-xs text-center mb-2">
              {planetarySystem.current.isInsidePlanet ? 
                `Exploring ${planetarySystem.current.currentPlanet?.userData.name} Surface` :
                "Universe Simulation - Navigate through space"
              }
            </div>
            <div className="flex items-center gap-2">
              <span className="text-white text-xs">⏱️</span>
              <input
                type="range"
                min="0"
                max="10"
                step="0.5"
                value={timeSpeed}
                onChange={(e) => setTimeSpeed(parseFloat(e.target.value))}
                className="flex-1 h-1"
              />
              <span className="text-white text-xs font-mono">{timeSpeed}x</span>
            </div>
          </div>
        </>
      ) : (
        <>
          {/* Desktop UI */}
          <div className="absolute top-4 left-4 bg-black/60 backdrop-blur px-3 py-2 rounded-lg text-white">
            <div className="text-sm font-bold mb-1">{getScaleLabel()}</div>
            <div className="text-xs space-y-1 text-gray-300">
              {planetarySystem.current.isInsidePlanet ? (
                <>
                  <div>🪐 Surface Mode Active</div>
                  <div>Mouse: Look around</div>
                  <div>WASD: Move on surface</div>
                  <div>Scroll: Altitude control</div>
                </>
              ) : (
                <>
                  <div>Click to capture mouse</div>
                  <div>WASD + Mouse to fly</div>
                  <div>Space/Shift: Up/Down</div>
                  <div>ESC: Release mouse</div>
                </>
              )}
            </div>
            {planetarySystem.current.isInsidePlanet && (
              <div className="text-yellow-400 text-xs mt-1">
                ⚠️ Camera locked to {planetarySystem.current.currentPlanet?.userData.name}
              </div>
            )}
          </div>

          {/* Exit Planet Button - Desktop */}
          {planetarySystem.current.isInsidePlanet && (
            <div className="absolute top-4 right-4">
              <button
                onClick={() => exitPlanetMode.current?.()}
                className="bg-red-600/80 hover:bg-red-700/80 backdrop-blur px-4 py-2 rounded-lg text-white text-sm font-bold transition-colors shadow-lg"
              >
                🚀 Exit Planet
              </button>
            </div>
          )}

          <div className="absolute bottom-4 left-4 bg-black/60 backdrop-blur p-2 rounded-lg">
            <div className="flex items-center gap-2">
              <span className="text-white text-xs">Time</span>
              <input
                type="range"
                min="0"
                max="10"
                step="0.5"
                value={timeSpeed}
                onChange={(e) => setTimeSpeed(parseFloat(e.target.value))}
                className="w-32 h-1"
              />
              <span className="text-white text-xs font-mono">{timeSpeed}x</span>
            </div>
          </div>
        </>
      )}
    </div>
  );
};

export default UniverseSimulation;
